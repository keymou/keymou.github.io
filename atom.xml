<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菲同一般</title>
  
  <subtitle>心有猛虎，細嗅薔薇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-19T15:04:27.862Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>keymou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件开发生命周期</title>
    <link href="http://yoursite.com/2018/12/18/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2018/12/18/软件开发生命周期/</id>
    <published>2018-12-18T08:17:32.000Z</published>
    <updated>2018-12-19T15:04:27.862Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算机行业流行一个笑话：有三样东西在制造过程中是永远看不见的——法律、香肠和软件。</p><a id="more"></a> <p>这种说法不完全对，但有些软件开发严格有序，有些软件控制却混乱不堪。软件产品从最初构思到公开发行的过程称为<em>软件开发生命周期模式。</em></p><p>以下是常用的模式：</p><ol><li><p><strong>大爆炸模式</strong></p><p>最简单的软件开发模式，优点是简单。计划、进度安排和正规开发过程几乎没有，所有精力花费在开发软件和编写代码上。</p></li><li><p><strong>编写边改模式</strong></p><p>通常只有粗略的想法，进行一些简单的设计，然后开始漫长的来回编写、测试和修改缺陷的过程，反复直到觉得足够了，就发布产品。</p></li><li><p><strong>瀑布模式</strong></p><p><img src="F:\自我提升\学习笔记\瀑布模式.png" alt="瀑布模式"></p><p>最典型的预见性的方法，严格遵循预先计划的需求分析、设计、编码、集成、测试、维护的步骤顺序进行。<br>步骤成果作为衡量进度的方法，例如需求规格，设计文档，测试计划和代码审阅等等。 </p><p>瀑布式的主要的问题是它的严格分级导致的自由度降低，项目早期即作出承诺导致对后期需求的变化难以调整，代价高昂。瀑布式方法在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。  </p></li><li><p><strong>螺旋模式</strong></p><p>核心就在于不需要在刚开始的时候就把所有事情都定义的清清楚楚。轻松上阵，定义最重要的功能，实现它，然后听取客户的意见，之后再进入到下一个阶段。</p><p>螺旋模式每一次循环包括6个步骤：</p><p>1）明确目标、可选方案和限制条件。</p><p>2）明确并化解风险。</p><p>3）评估可选方案。</p><p>4）当前阶段的开发和测试。</p><p>5）计划下一阶段。</p><p>6）确定进入下一阶段的方法。</p><p>螺旋模型很大程度上是一种风险驱动的方法体系，因为在每个阶段之前及经常发生的循环之前，都必须首先进行风险评估。</p></li><li><p><strong>迭代式开发</strong></p><p>也被称作<strong>迭代增量式开发</strong>或<strong>迭代进化式开发</strong>，是一种与传统的瀑布式开发相反的软件开发过程，它弥补了传统开发方式中的一些弱点，具有更高的成功率和生产率。</p><p>每次只设计和实现这个产品的一部分，逐步逐步完成的方法叫迭代开发，每次设计和实现一个阶段叫做一个迭代。</p><p>在迭代开发方法中，每一次迭代都包括了需求分析、设计、实现与测试。采用这种方法，开发工作可以在需求被完整地确定之前启动，并在一次迭代中完成系统的一部分功能或业务逻辑的开发工作。再通过客户的反馈来细化需求，并开始新一轮的迭代。</p><p>迭代式开发的优点：<br>　　1、降低风险<br>　　2、得到早期用户反馈<br>　　3、持续的测试和集成<br>　　4、使用变更<br>　　5、提高复用性</p></li></ol><p>   <strong>敏捷软件开发</strong></p><p>   又称<strong>敏捷开发</strong>，是一种应对快速变化的需求的一种软件开发能力。更强调程序员团队与业务专家之间的紧密协作、面对面的沟通、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发中人的作用。</p><p>   敏捷开发的目的：</p><blockquote><p>通过过程和工具理解个人和交流的作用</p><p>通过全面的文档理解运行的软件</p><p>通过合同和谈判得到客户的协作</p><p>在计划的执行中做出对变更的响应</p></blockquote><p>   迭代开发是<strong>一种</strong>软件开发的<strong>生命周期模型</strong>，敏捷开发是多种软件开发项目管理方法的集合，其中包括了XP、Scrum等，简单来说，<strong>迭代式开发模型是敏捷开发普遍使用的软件生命周期模型</strong>，<strong>敏捷开发所包含的内容比迭代模型宽泛的多</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机行业流行一个笑话：有三样东西在制造过程中是永远看不见的——法律、香肠和软件。&lt;/p&gt;
    
    </summary>
    
      <category term="软件开发" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="软件开发" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>アンナチュラル</title>
    <link href="http://yoursite.com/2018/12/16/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/"/>
    <id>http://yoursite.com/2018/12/16/アンナチュラル/</id>
    <published>2018-12-16T02:20:38.000Z</published>
    <updated>2018-12-16T02:21:53.284Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>又是一个周末啦，安利一部日剧《アンナチュラル》非自然死亡  </p><a id="more"></a>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=560738533&auto=1&height=66"></iframe>  <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>三澄美琴（石原里美 饰）是在民间法医组织“UDI”工作的女法医，该组织专门接收由于非正常原因导致死亡的遗体，对其进行解剖以求找到案件的真相。和美琴一起工作的，还有法医中堂系（井浦新 饰）、记录员九部六郎（洼田正孝 饰）和检查技师东海林夕子（市川实日子 饰）等人。 中堂系虽然拥有着丰富的临床经验，个性却乖僻古怪，对正义和法律理解不同的美琴和中堂之间，常常产生无法调和的矛盾。其实，中堂有一个无人知晓的秘密，他的女友在一场“意外”中不幸丧生，可种种蛛丝马迹向中堂揭示了，是一名连环杀人犯取走了女友的性命。中堂不畏人言坚定的留在UDI，正是为了找到杀死女友的凶手。  </p><p>剧情我就不剧透了，优酷、芒果有资源。  </p><p><a href="https://list.youku.com/show/id_zefbfbd3e4cefbfbd03ef.html?spm=a2h0j.11185381.bpmodule-playpage-lefttitle.5~5~H1~8~A" target="_blank" rel="noopener">优酷</a> | <a href="https://www.mgtv.com/h/321935.html?fpa=se" target="_blank" rel="noopener">芒果TV</a>  </p><h4 id="经典台词"><a href="#经典台词" class="headerlink" title="经典台词"></a>经典台词</h4><font face="黑体" color="#FFB6C1"><center>伴侣就要找那种睡相让你觉得很喜欢的人</center></font><br><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj5cjpcj21hc0swhdt.jpg" alt="01"><br><br><font face="黑体" color="#FFB6C1"><center>男女关系中是不会只有一方有错的</center></font><br><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj5zpj5j21gn0v00wv.jpg" alt="02"><br><br><font face="黑体" color="#FFB6C1"><center>有工夫绝望的话 还不如吃点好吃的去睡觉呢</center></font><br><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj66bkjj21hc0u07wh.jpg" alt="03"><br><br><font face="黑体" color="#FFB6C1"><center>只是把孩子当作自己的所有物，不明白孩子跟自己是互相独立的个体</center></font><br><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7ujvswm6j21hc0w3n2f.jpg" alt="04"><br><br><font face="黑体" color="#FFB6C1"><center>对女性的歧视</center></font><br><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj6dikfj21gw0uqq90.jpg" alt="05"><br><br><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj6gr3bj21hc0v242y.jpg" alt="06"><br><br><font face="黑体" color="#FFB6C1"><center>人这种生物 不管是谁<br>切开来剥皮后都只是一团肉而已<br>死了就明白了</center></font>  <p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj6n1srj21h80z9jxk.jpg" alt="07">  </p><font face="黑体" color="#CD5C5C"><center>特别认同中堂这段话，人生不就是这样嘛</center></font>  <p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7ujueenxj21hc0u0427.jpg" alt="08">  </p><font face="黑体" color="#FFB6C1"><center>为了活下去</center></font>  <p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7ujvpv2qj21hc0w4ae0.jpg" alt="09"><br> <font face="黑体" color="#FF00FF"><center>梦想什么的<br>也没必要说得那么夸张<br>有个目标就行<br></center></font>  </p><p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj6rq57j21gi0tyjzr.jpg" alt="10">  </p><p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj7ffjgj21hc0sw1kz.jpg" alt="11">  </p><font face="黑体" color="#FFB6C1"><center>每个人都是罪人 为了赎罪而工作</center></font>  <p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7ujwwgyjj21hc0y7wjv.jpg" alt="12">  </p><font face="黑体" color="#FF4500"><center><br>不管女性穿什么样的衣服<br>或者喝得酩酊大醉<br>都不能成为肆意妄为的理由<br>没有得到双方一致同意的性行为就是犯罪<br></center></font>    <p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uk5sx0bj21hc0z9txg.jpg" alt="13">  </p><font face="黑体" color="#FFB6C1"><center>欺凌杀人</center></font>  <p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uk6a6ngj21hc17lb29.jpg" alt="14">  </p><font face="黑体"><center>你就算献出了自己的生命<br>你的痛楚<br>肯定也无法传达给他们<br>你的人生 &nbsp;属于你自己</center></font>  <p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uk6rz0gj21hc0sw4qq.jpg" alt="15">  </p><p><font face="黑体" color="#008000"><center>看官点个赞再走吧</center></font><br><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uk5k7txj21hc0u01ky.jpg" alt="16">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是一个周末啦，安利一部日剧《アンナチュラル》非自然死亡  &lt;/p&gt;
    
    </summary>
    
      <category term="日剧" scheme="http://yoursite.com/categories/%E6%97%A5%E5%89%A7/"/>
    
    
      <category term="石原里美,日剧" scheme="http://yoursite.com/tags/%E7%9F%B3%E5%8E%9F%E9%87%8C%E7%BE%8E-%E6%97%A5%E5%89%A7/"/>
    
  </entry>
  
  <entry>
    <title>python常见知识点</title>
    <link href="http://yoursite.com/2018/12/14/python%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/12/14/python常见知识点/</id>
    <published>2018-12-14T10:23:08.000Z</published>
    <updated>2018-12-16T03:32:06.270Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在学习python，总结了下python常用的知识点。</p><a id="more"></a><h4 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">def fun(a):</span><br><span class="line">    a = 2</span><br><span class="line">fun(a)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = []</span><br><span class="line">def fun(b):</span><br><span class="line">    b.append(1)</span><br><span class="line">fun(b)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>所有的变量都可以理解是内存中一个对象的“引用”。类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。<br>在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。</p><h4 id="实例方法、类方法、静态方法"><a href="#实例方法、类方法、静态方法" class="headerlink" title="实例方法、类方法、静态方法"></a>实例方法、类方法、静态方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def foo(x):</span><br><span class="line">    print(&quot;executing foo(%s)&quot;%(x))</span><br><span class="line"></span><br><span class="line">class A(object):</span><br><span class="line">    def foo(self,x):</span><br><span class="line">        print(&quot;executing foo(%s,%s)&quot;%(self,x))</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def class_foo(cls,x):</span><br><span class="line">        print(&quot;executing class_foo(%s,%s)&quot;%(cls,x))</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def static_foo(x):</span><br><span class="line">        print(&quot;executing static_foo(%s)&quot;%x)</span><br><span class="line"></span><br><span class="line">a=A()</span><br><span class="line">a.foo(2)</span><br><span class="line">a.class_foo(2)</span><br><span class="line">a.static_foo(2)</span><br></pre></td></tr></table></figure><p>先理解下函数参数里面的<code>self</code>和<code>cls</code>。这个<code>self</code>和<code>cls</code>是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.<br>对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>).<br>类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)</code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.</p><p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p><table><thead><tr><th>\</th><th>实例方法</th><th>类方法</th><th>静态方法</th></tr></thead><tbody><tr><td><code>a = A()</code></td><td><code>a.foo(x)</code></td><td><code>a.class_foo(x)</code></td><td><code>a.static_foo(x)</code></td></tr><tr><td><code>A</code></td><td>不可用</td><td><code>A.class_foo(x)</code></td><td><code>A.static_foo(x)</code></td></tr></tbody></table><h4 id="类变量、实例变量"><a href="#类变量、实例变量" class="headerlink" title="类变量、实例变量"></a>类变量、实例变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    name=&quot;aaa&quot;</span><br><span class="line"> </span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=&quot;bbb&quot;</span><br><span class="line">print(p1.name)  # bbb</span><br><span class="line">print(p2.name)  # aaa</span><br><span class="line">print(Person.name)  # aaa</span><br></pre></td></tr></table></figure><p>类变量就是供类使用的变量,实例变量就是供实例使用的。</p><h4 id="Python自省"><a href="#Python自省" class="headerlink" title="Python自省"></a>Python自省</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">b = &apos;Hello&apos;</span><br><span class="line">print(type(a), type(b))</span><br></pre></td></tr></table></figure><ul><li>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型。<br>比如type()、dir()、getattr()、hasattr()、isinstance()</li></ul><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">multiples = [i for i in range(30) if i % 3 is 0]</span><br><span class="line">print(multiples)</span><br><span class="line"></span><br><span class="line">mcase = &#123;&apos;a&apos;: 10, &apos;b&apos;: 34, &apos;A&apos;: 7, &apos;Z&apos;: 3&#125;</span><br><span class="line"></span><br><span class="line">mcase_frequency = &#123;</span><br><span class="line">    k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0)</span><br><span class="line">    for k in mcase.keys()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(mcase_frequency)</span><br><span class="line"># mcase_frequency == &#123;&apos;a&apos;: 17, &apos;z&apos;: 3, &apos;b&apos;: 34&#125;</span><br></pre></td></tr></table></figure><ul><li>列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。规范:<code>variable = [out_exp for out_exp in input_list if out_exp == 2]</code></li><li>字典推导式，上述例子把同一个字母但不同大小写的值合并起来。<br>可以快速对换一个字典的键和值：<br><code>{v: k for k, v in dict.items()}</code></li></ul><h4 id="单下划线和双下划线"><a href="#单下划线和双下划线" class="headerlink" title="单下划线和双下划线"></a>单下划线和双下划线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyClass():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__superprivate = &apos;Hello&apos;</span><br><span class="line">        self._semiprivate = &apos;, world&apos;</span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line">print(mc._semiprivate)</span><br><span class="line">print(mc.__dict__)</span><br><span class="line"># print(mc.__superprivate)</span><br><span class="line"># AttributeError: &apos;MyClass&apos; object has no attribute &apos;__superprivate&apos;</span><br></pre></td></tr></table></figure><ul><li><code>__foo__</code>：一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突.</li><li><code>_foo</code>：一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.</li><li><code>__foo</code>：这个有真正的意义:解析器用_classname__foo来代替这个名字,以区别和其他类相同的命名.</li></ul><h4 id="字符串格式化：-和-format的区别"><a href="#字符串格式化：-和-format的区别" class="headerlink" title="字符串格式化：%和.format的区别"></a>字符串格式化：%和.format的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = &apos;Joe&apos;</span><br><span class="line">print(&apos;Name is %s&apos; %name)</span><br><span class="line">print(&apos;Name is &#123;&#125;&apos;.format(name))</span><br><span class="line">name = (1, 2, 3)</span><br><span class="line"># print(&apos;Name is %s&apos; %name)  # TypeError: not all arguments converted during string formatting</span><br><span class="line">print(&apos;Name is &#123;&#125;&apos;.format(name))</span><br><span class="line">print(&apos;Name is %s&apos; %(name,))</span><br></pre></td></tr></table></figure><p><code>format</code>简洁，<code>%</code>无法同时传递一个变量和元组</p><h4 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mylist = [1, 2, 3]</span><br><span class="line">for i in mylist:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"># mylist is an iterable</span><br><span class="line"># These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.</span><br><span class="line"></span><br><span class="line"># yield is a keyword that is used like return, except the function will return a generator.</span><br><span class="line">def createGenerator():</span><br><span class="line">    mylist = range(3)</span><br><span class="line">    for i in mylist:</span><br><span class="line">        yield i*i</span><br><span class="line"></span><br><span class="line"># create a generator</span><br><span class="line">mygenerator = createGenerator()</span><br><span class="line">print(mygenerator)</span><br><span class="line">for i in mygenerator:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">print(&apos;****&apos;)</span><br><span class="line"># To master yield, you must understand that when you call the function, the code you have written in the function body does not run.</span><br><span class="line">for j in mygenerator:</span><br><span class="line">    print(j)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Generators are iterators, a kind of iterable you can only iterate over once. Generators do not store all the values in memory, they generate the values on the fly.</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h4 id="args-and-kwargs”"><a href="#args-and-kwargs”" class="headerlink" title="*args and **kwargs”"></a>*args and **kwargs”</h4><p>不确定你的函数里将要传递多少参数时你可以用<code>*args</code>。例如，它可以传递任意数量的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def print_everything(*args):</span><br><span class="line">    for count, thing in enumerate(args):</span><br><span class="line">        print(&apos;&#123;0&#125;. &#123;1&#125;&apos;.format(count, thing))</span><br><span class="line"></span><br><span class="line">print_everything(&apos;apple&apos;, &apos;banana&apos;, &apos;cabbage&apos;)</span><br></pre></td></tr></table></figure></p><p><code>**kwargs</code>允许你使用没有事先定义的参数名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def table_things(**kwargs):</span><br><span class="line">    for name, value in kwargs.items():</span><br><span class="line">        print(&apos;&#123;0&#125;=&#123;1&#125;&apos;.format(name, value))</span><br><span class="line"></span><br><span class="line">table_things(apple = &apos;fruit&apos;, cabbage = &apos;vegetable&apos;)</span><br></pre></td></tr></table></figure></p><p>也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给<code>*args</code>和<code>**kwargs</code>。命名参数在列表的最前端，<code>*args</code>和<code>**kwargs</code>可以同时在函数的定义中，但是<code>*args</code>必须在<code>**kwargs</code>前面.</p><h4 id="面向切面编程AOP和装饰器"><a href="#面向切面编程AOP和装饰器" class="headerlink" title="面向切面编程AOP和装饰器"></a>面向切面编程AOP和装饰器</h4><ul><li>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。</li><li><p>装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。<br><strong>概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def makebold(fn):</span><br><span class="line">   def wrapped():</span><br><span class="line">       return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;/b&gt;&quot;</span><br><span class="line">   return wrapped</span><br><span class="line"></span><br><span class="line">def makeitalic(fn):</span><br><span class="line">   def wrapped():</span><br><span class="line">       return &quot;&lt;i&gt;&quot; + fn() + &quot;&lt;/i&gt;&quot;</span><br><span class="line">   return wrapped</span><br></pre></td></tr></table></figure></li><li><p>装饰器的作用就是为已经存在的对象添加额外的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@makebold</span><br><span class="line">@makeitalic</span><br><span class="line">def hello():</span><br><span class="line">    return &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">print(hello())</span><br></pre></td></tr></table></figure></li></ul><h4 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h4><p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为<em>鸭子</em>。<br>并不关心对象是什么类型，到底是不是鸭子，只关心行为。<br>在python中，有很多file-like的东西，比如<code>StringIO</code>,<code>GzipFile</code>,<code>socket</code>。它们有很多相同的方法，我们把它们当作文件使用。</p><h4 id="Python中函数重载"><a href="#Python中函数重载" class="headerlink" title="Python中函数重载"></a>Python中函数重载</h4><ul><li>函数重载主要是为了解决两个问题:可变参数类型、可变参数个数。</li><li>一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载。<br>情况1：函数功能相同，但是参数类型不同，根本不需要处理，因为python可以接受任何类型的参数<br>情况2：函数功能相同，但参数个数不同，答案就是缺省参数。<br><strong>python 自然就不需要函数重载。</strong></li></ul><h4 id="new和init的区别"><a href="#new和init的区别" class="headerlink" title="new和init的区别"></a><strong>new</strong>和<strong>init</strong>的区别</h4><ul><li><code>__new__</code>是一个静态方法,而<code>__init__</code>是一个实例方法.</li><li><code>__new__</code>方法会返回一个创建的实例,而<code>__init__</code>什么都不返回.</li><li>只有在<code>__new__</code>返回一个<code>cls</code>的实例时后面的<code>__init__</code>才能被调用.</li><li>当创建一个新实例时调用<code>__new__</code>,初始化一个实例时用<code>__init__</code>.</li></ul><p>ps: <strong>metaclass</strong>是创建类时起作用.所以我们可以分别使用<strong>metaclass</strong>,<strong>new</strong>和<strong>init</strong>来分别在类创建,实例创建和实例初始化的时候做一些小手脚.</p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><h5 id="使用new方法"><a href="#使用new方法" class="headerlink" title="使用new方法"></a>使用<strong>new</strong>方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    def __new__(cls, *args, **kw):</span><br><span class="line">        if not hasattr(cls, &apos;_instance&apos;):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        return cls._instance</span><br><span class="line"> </span><br><span class="line">class MyClass(Singleton):</span><br><span class="line">    a = 1</span><br></pre></td></tr></table></figure><h5 id="共享属性-创建实例时把所有实例的-dict-指向同一个字典-这样它们具有相同的属性和方法"><a href="#共享属性-创建实例时把所有实例的-dict-指向同一个字典-这样它们具有相同的属性和方法" class="headerlink" title="共享属性 创建实例时把所有实例的__dict__指向同一个字典,这样它们具有相同的属性和方法."></a>共享属性 创建实例时把所有实例的<code>__dict__</code>指向同一个字典,这样它们具有相同的属性和方法.</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Borg(object):</span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    def __new__(cls, *args, **kw):</span><br><span class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        return ob</span><br><span class="line"> </span><br><span class="line">class MyClass2(Borg):</span><br><span class="line">    a = 1</span><br></pre></td></tr></table></figure><h5 id="装饰器版本"><a href="#装饰器版本" class="headerlink" title="装饰器版本"></a>装饰器版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def singleton(cls, *args, **kw):</span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    def getinstance():</span><br><span class="line">        if cls not in instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        return instances[cls]</span><br><span class="line">    return getinstance</span><br><span class="line"> </span><br><span class="line">@singleton</span><br><span class="line">class MyClass:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h5 id="import方法"><a href="#import方法" class="headerlink" title="import方法"></a>import方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mysingleton.py</span><br><span class="line">class My_Singleton(object):</span><br><span class="line">    def foo(self):</span><br><span class="line">        pass</span><br><span class="line"> </span><br><span class="line">my_singleton = My_Singleton()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># to use</span><br><span class="line"># from mysingleton import my_singleton</span><br><span class="line"># my_singleton.foo()</span><br></pre></td></tr></table></figure><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul><li>一个变量的作用域总是由在代码中被赋值的地方所决定的。</li><li>当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：</li><li>本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）</li></ul><h4 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h4><p>闭包(closure)是函数式编程的重要的语法结构<br>创建一个闭包必须满足以下几点:</p><ul><li>必须有一个内嵌函数</li><li>内嵌函数必须引用外部函数中的变量</li><li>外部函数的返回值必须是内嵌函数</li></ul><h4 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h4><p>lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map( lambda x: x*x, [y for y in range(10)] )</span><br></pre></td></tr></table></figure></p><h4 id="Python里的拷贝"><a href="#Python里的拷贝" class="headerlink" title="Python里的拷贝"></a>Python里的拷贝</h4><ul><li>copy浅拷贝，没有拷贝子对象，所以原始数据改变，子对象会改变</li><li>深拷贝，包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">a = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]]  #原始对象</span><br><span class="line"> </span><br><span class="line">b = a  #赋值，传对象的引用</span><br><span class="line">c = copy.copy(a)  #对象拷贝，浅拷贝</span><br><span class="line">d = copy.deepcopy(a)  #对象拷贝，深拷贝</span><br><span class="line"> </span><br><span class="line">a.append(5)  #修改对象a</span><br><span class="line">a[4].append(&apos;c&apos;)  #修改对象a中的[&apos;a&apos;, &apos;b&apos;]数组对象</span><br><span class="line"> </span><br><span class="line">print(&apos;a = &apos;, a)</span><br><span class="line">print(&apos;b = &apos;, b)</span><br><span class="line">print(&apos;c = &apos;, c)</span><br><span class="line">print(&apos;d = &apos;, d)</span><br><span class="line"></span><br><span class="line"># 输出结果：</span><br><span class="line"># a =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]</span><br><span class="line"># b =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]</span><br><span class="line"># c =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]</span><br><span class="line"># d =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]]</span><br></pre></td></tr></table></figure></li></ul><h4 id="Python垃圾回收机制"><a href="#Python垃圾回收机制" class="headerlink" title="Python垃圾回收机制"></a>Python垃圾回收机制</h4><p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。<br>在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p><ol><li>引用计数<br>PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。</li><li>标记-清除机制<br>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</li><li>分代技术<br>整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</li></ol><h4 id="Python的is"><a href="#Python的is" class="headerlink" title="Python的is"></a>Python的is</h4><p><code>is</code>是对比地址，<code>==</code>是对比值</p><h4 id="read，readline和readlines"><a href="#read，readline和readlines" class="headerlink" title="read，readline和readlines"></a>read，readline和readlines</h4><ul><li><code>read</code> 读取整个文件</li><li><code>readline</code> 读取下一行,使用生成器方法</li><li><code>readlines</code> 读取整个文件到一个迭代器以供我们遍历</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习python，总结了下python常用的知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
</feed>
