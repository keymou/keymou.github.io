<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菲同一般</title>
  
  <subtitle>心有猛虎，細嗅薔薇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-15T11:45:11.167Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>keymou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日剧《Unnatural》</title>
    <link href="http://yoursite.com/2018/12/15/%E6%97%A5%E5%89%A7%E3%80%8AUnnatural%E3%80%8B/"/>
    <id>http://yoursite.com/2018/12/15/日剧《Unnatural》/</id>
    <published>2018-12-15T10:22:30.000Z</published>
    <updated>2018-12-15T11:45:11.167Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>又是一个周末啦，安利一部日剧《アンナチュラル》非自然死亡</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=560738533&auto=1&height=66"></iframe><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>三澄美琴（石原里美 饰）是在民间法医组织“UDI”工作的女法医，该组织专门接收由于非正常原因导致死亡的遗体，对其进行解剖以求找到案件的真相。和美琴一起工作的，还有法医中堂系（井浦新 饰）、记录员九部六郎（洼田正孝 饰）和检查技师东海林夕子（市川实日子 饰）等人。 中堂系虽然拥有着丰富的临床经验，个性却乖僻古怪，对正义和法律理解不同的美琴和中堂之间，常常产生无法调和的矛盾。其实，中堂有一个无人知晓的秘密，他的女友在一场“意外”中不幸丧生，可种种蛛丝马迹向中堂揭示了，是一名连环杀人犯取走了女友的性命。中堂不畏人言坚定的留在UDI，正是为了找到杀死女友的凶手。</p><h5 id="经典台词"><a href="#经典台词" class="headerlink" title="经典台词"></a>经典台词</h5><p>“人这种生物，不管是谁，切开来剥皮后都只是一团肉而已，死了就明白了。”中堂在法庭上说出的这句话，我不能更加认同了，因为这就是我一直以来的生死观。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是一个周末啦，安利一部日剧《アンナチュラル》非自然死亡&lt;/p&gt;
    
    </summary>
    
      <category term="日剧" scheme="http://yoursite.com/categories/%E6%97%A5%E5%89%A7/"/>
    
    
      <category term="Unnatural" scheme="http://yoursite.com/tags/Unnatural/"/>
    
  </entry>
  
  <entry>
    <title>Github+Hexo搭建个人博客</title>
    <link href="http://yoursite.com/2018/12/14/Github-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/12/14/Github-Hexo搭建个人博客/</id>
    <published>2018-12-14T12:26:35.000Z</published>
    <updated>2018-12-15T07:16:14.619Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>在茫茫互联网中拥有一处小窝，记录北漂的生活。</strong></p><p>很久之前就想动手搭建个人博客，但感觉很难所以就一直没敢去尝试。最近实在无所事事，就动手尝试搭建一个属于自己的个人博客。</p><a id="more"></a><h4 id="搭建环境准备"><a href="#搭建环境准备" class="headerlink" title="搭建环境准备"></a>搭建环境准备</h4><h5 id="软件安装配置"><a href="#软件安装配置" class="headerlink" title="软件安装配置"></a>软件安装配置</h5><ul><li><p>安装node.js<br>官网：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a><br>提供JavaScript的开发环境，安装好以后就不用跟它再打交道，所以不用太关注它。<br>安装完有返回版本信息说明安装成功；同样还得安装npm，安装成功后，打开cmd窗口运行下面命令，如果有返回版本信息说明安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li><li><p>安装Git<br>官网：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a><br>软件安装过程很简单，一直点击Next默认直到安装完成就行了。安装完，打开cmd窗口运行下面命令，如果有返回版本信息说明安装成功。<code>git –version</code></p></li><li><p>安装Hexo博客框架</p><ol><li><p>安装hexo<br>右键点击git bash here选项，会打开Git软件界面，输入下面每行命令并回车：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>第一行是安装hexo，第二行代码是安装hexo部署到git page的deployer，只需要了解，后面基本很少用到。</p></li><li><p>设置博客文件项目<br>在除C盘以外的盘符创建一个文件目录作为blog文件夹，鼠标右键点击git bash here,依次输入下面命令并回车：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p>查看博客效果<br>输入下面一行本地部署生成的命令：<code>hexo s -g</code><br>然后打开浏览器在网址栏输入：localhost:4000就可以看到博客的样子，如果无法打开，则继续输入下面命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo s -g</span><br></pre></td></tr></table></figure><p>打开该网址，你可以看到第一篇默认的博客：Hello World。但看起来很难看，后续会通过重新选择模板来对博客进行美化。</p></li></ol></li></ul><h5 id="把你的博客部署到Github-Pages上去"><a href="#把你的博客部署到Github-Pages上去" class="headerlink" title="把你的博客部署到Github Pages上去"></a>把你的博客部署到Github Pages上去</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;在茫茫互联网中拥有一处小窝，记录北漂的生活。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很久之前就想动手搭建个人博客，但感觉很难所以就一直没敢去尝试。最近实在无所事事，就动手尝试搭建一个属于自己的个人博客。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Github,Hexo" scheme="http://yoursite.com/tags/Github-Hexo/"/>
    
  </entry>
  
  <entry>
    <title>python常见知识点</title>
    <link href="http://yoursite.com/2018/12/14/python%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2018/12/14/python常见知识点/</id>
    <published>2018-12-14T10:23:08.000Z</published>
    <updated>2018-12-15T02:31:56.527Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在学习python，总结了下python常用的知识点。</p><a id="more"></a><h4 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">def fun(a):</span><br><span class="line">    a = 2</span><br><span class="line">fun(a)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = []</span><br><span class="line">def fun(b):</span><br><span class="line">    b.append(1)</span><br><span class="line">fun(b)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>所有的变量都可以理解是内存中一个对象的“引用”。类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。<br>在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。</p><h4 id="实例方法、类方法、静态方法"><a href="#实例方法、类方法、静态方法" class="headerlink" title="实例方法、类方法、静态方法"></a>实例方法、类方法、静态方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def foo(x):</span><br><span class="line">    print(&quot;executing foo(%s)&quot;%(x))</span><br><span class="line"></span><br><span class="line">class A(object):</span><br><span class="line">    def foo(self,x):</span><br><span class="line">        print(&quot;executing foo(%s,%s)&quot;%(self,x))</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def class_foo(cls,x):</span><br><span class="line">        print(&quot;executing class_foo(%s,%s)&quot;%(cls,x))</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def static_foo(x):</span><br><span class="line">        print(&quot;executing static_foo(%s)&quot;%x)</span><br><span class="line"></span><br><span class="line">a=A()</span><br><span class="line">a.foo(2)</span><br><span class="line">a.class_foo(2)</span><br><span class="line">a.static_foo(2)</span><br></pre></td></tr></table></figure><p>先理解下函数参数里面的<code>self</code>和<code>cls</code>。这个<code>self</code>和<code>cls</code>是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.<br>对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>).<br>类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)</code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.</p><p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p><table><thead><tr><th>\</th><th>实例方法</th><th>类方法</th><th>静态方法</th></tr></thead><tbody><tr><td><code>a = A()</code></td><td><code>a.foo(x)</code></td><td><code>a.class_foo(x)</code></td><td><code>a.static_foo(x)</code></td></tr><tr><td><code>A</code></td><td>不可用</td><td><code>A.class_foo(x)</code></td><td><code>A.static_foo(x)</code></td></tr></tbody></table><h4 id="类变量、实例变量"><a href="#类变量、实例变量" class="headerlink" title="类变量、实例变量"></a>类变量、实例变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    name=&quot;aaa&quot;</span><br><span class="line"> </span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=&quot;bbb&quot;</span><br><span class="line">print(p1.name)  # bbb</span><br><span class="line">print(p2.name)  # aaa</span><br><span class="line">print(Person.name)  # aaa</span><br></pre></td></tr></table></figure><p>类变量就是供类使用的变量,实例变量就是供实例使用的。</p><h4 id="Python自省"><a href="#Python自省" class="headerlink" title="Python自省"></a>Python自省</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">b = &apos;Hello&apos;</span><br><span class="line">print(type(a), type(b))</span><br></pre></td></tr></table></figure><ul><li>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型。<br>比如type()、dir()、getattr()、hasattr()、isinstance()</li></ul><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">multiples = [i for i in range(30) if i % 3 is 0]</span><br><span class="line">print(multiples)</span><br><span class="line"></span><br><span class="line">mcase = &#123;&apos;a&apos;: 10, &apos;b&apos;: 34, &apos;A&apos;: 7, &apos;Z&apos;: 3&#125;</span><br><span class="line"></span><br><span class="line">mcase_frequency = &#123;</span><br><span class="line">    k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0)</span><br><span class="line">    for k in mcase.keys()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(mcase_frequency)</span><br><span class="line"># mcase_frequency == &#123;&apos;a&apos;: 17, &apos;z&apos;: 3, &apos;b&apos;: 34&#125;</span><br></pre></td></tr></table></figure><ul><li>列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。规范:<code>variable = [out_exp for out_exp in input_list if out_exp == 2]</code></li><li>字典推导式，上述例子把同一个字母但不同大小写的值合并起来。<br>可以快速对换一个字典的键和值：<br><code>{v: k for k, v in dict.items()}</code></li></ul><h4 id="单下划线和双下划线"><a href="#单下划线和双下划线" class="headerlink" title="单下划线和双下划线"></a>单下划线和双下划线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyClass():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__superprivate = &apos;Hello&apos;</span><br><span class="line">        self._semiprivate = &apos;, world&apos;</span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line">print(mc._semiprivate)</span><br><span class="line">print(mc.__dict__)</span><br><span class="line"># print(mc.__superprivate)</span><br><span class="line"># AttributeError: &apos;MyClass&apos; object has no attribute &apos;__superprivate&apos;</span><br></pre></td></tr></table></figure><ul><li><code>__foo__</code>：一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突.</li><li><code>_foo</code>：一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.</li><li><code>__foo</code>：这个有真正的意义:解析器用_classname__foo来代替这个名字,以区别和其他类相同的命名.</li></ul><h4 id="字符串格式化：-和-format的区别"><a href="#字符串格式化：-和-format的区别" class="headerlink" title="字符串格式化：%和.format的区别"></a>字符串格式化：%和.format的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = &apos;Joe&apos;</span><br><span class="line">print(&apos;Name is %s&apos; %name)</span><br><span class="line">print(&apos;Name is &#123;&#125;&apos;.format(name))</span><br><span class="line">name = (1, 2, 3)</span><br><span class="line"># print(&apos;Name is %s&apos; %name)  # TypeError: not all arguments converted during string formatting</span><br><span class="line">print(&apos;Name is &#123;&#125;&apos;.format(name))</span><br><span class="line">print(&apos;Name is %s&apos; %(name,))</span><br></pre></td></tr></table></figure><p><code>format</code>简洁，<code>%</code>无法同时传递一个变量和元组</p><h4 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mylist = [1, 2, 3]</span><br><span class="line">for i in mylist:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"># mylist is an iterable</span><br><span class="line"># These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.</span><br><span class="line"></span><br><span class="line"># yield is a keyword that is used like return, except the function will return a generator.</span><br><span class="line">def createGenerator():</span><br><span class="line">    mylist = range(3)</span><br><span class="line">    for i in mylist:</span><br><span class="line">        yield i*i</span><br><span class="line"></span><br><span class="line"># create a generator</span><br><span class="line">mygenerator = createGenerator()</span><br><span class="line">print(mygenerator)</span><br><span class="line">for i in mygenerator:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">print(&apos;****&apos;)</span><br><span class="line"># To master yield, you must understand that when you call the function, the code you have written in the function body does not run.</span><br><span class="line">for j in mygenerator:</span><br><span class="line">    print(j)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Generators are iterators, a kind of iterable you can only iterate over once. Generators do not store all the values in memory, they generate the values on the fly.</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h4 id="args-and-kwargs”"><a href="#args-and-kwargs”" class="headerlink" title="*args and **kwargs”"></a>*args and **kwargs”</h4><p>不确定你的函数里将要传递多少参数时你可以用<code>*args</code>。例如，它可以传递任意数量的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def print_everything(*args):</span><br><span class="line">    for count, thing in enumerate(args):</span><br><span class="line">        print(&apos;&#123;0&#125;. &#123;1&#125;&apos;.format(count, thing))</span><br><span class="line"></span><br><span class="line">print_everything(&apos;apple&apos;, &apos;banana&apos;, &apos;cabbage&apos;)</span><br></pre></td></tr></table></figure></p><p><code>**kwargs</code>允许你使用没有事先定义的参数名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def table_things(**kwargs):</span><br><span class="line">    for name, value in kwargs.items():</span><br><span class="line">        print(&apos;&#123;0&#125;=&#123;1&#125;&apos;.format(name, value))</span><br><span class="line"></span><br><span class="line">table_things(apple = &apos;fruit&apos;, cabbage = &apos;vegetable&apos;)</span><br></pre></td></tr></table></figure></p><p>也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给<code>*args</code>和<code>**kwargs</code>。命名参数在列表的最前端，<code>*args</code>和<code>**kwargs</code>可以同时在函数的定义中，但是<code>*args</code>必须在<code>**kwargs</code>前面.</p><h4 id="面向切面编程AOP和装饰器"><a href="#面向切面编程AOP和装饰器" class="headerlink" title="面向切面编程AOP和装饰器"></a>面向切面编程AOP和装饰器</h4><ul><li>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。</li><li><p>装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。<br><strong>概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def makebold(fn):</span><br><span class="line">   def wrapped():</span><br><span class="line">       return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;/b&gt;&quot;</span><br><span class="line">   return wrapped</span><br><span class="line"></span><br><span class="line">def makeitalic(fn):</span><br><span class="line">   def wrapped():</span><br><span class="line">       return &quot;&lt;i&gt;&quot; + fn() + &quot;&lt;/i&gt;&quot;</span><br><span class="line">   return wrapped</span><br></pre></td></tr></table></figure></li><li><p>装饰器的作用就是为已经存在的对象添加额外的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@makebold</span><br><span class="line">@makeitalic</span><br><span class="line">def hello():</span><br><span class="line">    return &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">print(hello())</span><br></pre></td></tr></table></figure></li></ul><h4 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h4><p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为<em>鸭子</em>。<br>并不关心对象是什么类型，到底是不是鸭子，只关心行为。<br>在python中，有很多file-like的东西，比如<code>StringIO</code>,<code>GzipFile</code>,<code>socket</code>。它们有很多相同的方法，我们把它们当作文件使用。</p><h4 id="Python中函数重载"><a href="#Python中函数重载" class="headerlink" title="Python中函数重载"></a>Python中函数重载</h4><ul><li>函数重载主要是为了解决两个问题:可变参数类型、可变参数个数。</li><li>一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载。<br>情况1：函数功能相同，但是参数类型不同，根本不需要处理，因为python可以接受任何类型的参数<br>情况2：函数功能相同，但参数个数不同，答案就是缺省参数。<br><strong>python 自然就不需要函数重载。</strong></li></ul><h4 id="new和init的区别"><a href="#new和init的区别" class="headerlink" title="new和init的区别"></a><strong>new</strong>和<strong>init</strong>的区别</h4><ul><li><code>__new__</code>是一个静态方法,而<code>__init__</code>是一个实例方法.</li><li><code>__new__</code>方法会返回一个创建的实例,而<code>__init__</code>什么都不返回.</li><li>只有在<code>__new__</code>返回一个<code>cls</code>的实例时后面的<code>__init__</code>才能被调用.</li><li>当创建一个新实例时调用<code>__new__</code>,初始化一个实例时用<code>__init__</code>.</li></ul><p>ps: <strong>metaclass</strong>是创建类时起作用.所以我们可以分别使用<strong>metaclass</strong>,<strong>new</strong>和<strong>init</strong>来分别在类创建,实例创建和实例初始化的时候做一些小手脚.</p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><h5 id="使用new方法"><a href="#使用new方法" class="headerlink" title="使用new方法"></a>使用<strong>new</strong>方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    def __new__(cls, *args, **kw):</span><br><span class="line">        if not hasattr(cls, &apos;_instance&apos;):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        return cls._instance</span><br><span class="line"> </span><br><span class="line">class MyClass(Singleton):</span><br><span class="line">    a = 1</span><br></pre></td></tr></table></figure><h5 id="共享属性-创建实例时把所有实例的-dict-指向同一个字典-这样它们具有相同的属性和方法"><a href="#共享属性-创建实例时把所有实例的-dict-指向同一个字典-这样它们具有相同的属性和方法" class="headerlink" title="共享属性 创建实例时把所有实例的__dict__指向同一个字典,这样它们具有相同的属性和方法."></a>共享属性 创建实例时把所有实例的<code>__dict__</code>指向同一个字典,这样它们具有相同的属性和方法.</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Borg(object):</span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    def __new__(cls, *args, **kw):</span><br><span class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        return ob</span><br><span class="line"> </span><br><span class="line">class MyClass2(Borg):</span><br><span class="line">    a = 1</span><br></pre></td></tr></table></figure><h5 id="装饰器版本"><a href="#装饰器版本" class="headerlink" title="装饰器版本"></a>装饰器版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def singleton(cls, *args, **kw):</span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    def getinstance():</span><br><span class="line">        if cls not in instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        return instances[cls]</span><br><span class="line">    return getinstance</span><br><span class="line"> </span><br><span class="line">@singleton</span><br><span class="line">class MyClass:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h5 id="import方法"><a href="#import方法" class="headerlink" title="import方法"></a>import方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mysingleton.py</span><br><span class="line">class My_Singleton(object):</span><br><span class="line">    def foo(self):</span><br><span class="line">        pass</span><br><span class="line"> </span><br><span class="line">my_singleton = My_Singleton()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># to use</span><br><span class="line"># from mysingleton import my_singleton</span><br><span class="line"># my_singleton.foo()</span><br></pre></td></tr></table></figure><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul><li>一个变量的作用域总是由在代码中被赋值的地方所决定的。</li><li>当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：</li><li>本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）</li></ul><h4 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h4><p>闭包(closure)是函数式编程的重要的语法结构<br>创建一个闭包必须满足以下几点:</p><ul><li>必须有一个内嵌函数</li><li>内嵌函数必须引用外部函数中的变量</li><li>外部函数的返回值必须是内嵌函数</li></ul><h4 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h4><p>lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map( lambda x: x*x, [y for y in range(10)] )</span><br></pre></td></tr></table></figure></p><h4 id="Python里的拷贝"><a href="#Python里的拷贝" class="headerlink" title="Python里的拷贝"></a>Python里的拷贝</h4><ul><li>copy浅拷贝，没有拷贝子对象，所以原始数据改变，子对象会改变</li><li>深拷贝，包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">a = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]]  #原始对象</span><br><span class="line"> </span><br><span class="line">b = a  #赋值，传对象的引用</span><br><span class="line">c = copy.copy(a)  #对象拷贝，浅拷贝</span><br><span class="line">d = copy.deepcopy(a)  #对象拷贝，深拷贝</span><br><span class="line"> </span><br><span class="line">a.append(5)  #修改对象a</span><br><span class="line">a[4].append(&apos;c&apos;)  #修改对象a中的[&apos;a&apos;, &apos;b&apos;]数组对象</span><br><span class="line"> </span><br><span class="line">print(&apos;a = &apos;, a)</span><br><span class="line">print(&apos;b = &apos;, b)</span><br><span class="line">print(&apos;c = &apos;, c)</span><br><span class="line">print(&apos;d = &apos;, d)</span><br><span class="line"></span><br><span class="line"># 输出结果：</span><br><span class="line"># a =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]</span><br><span class="line"># b =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]</span><br><span class="line"># c =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]</span><br><span class="line"># d =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]]</span><br></pre></td></tr></table></figure></li></ul><h4 id="Python垃圾回收机制"><a href="#Python垃圾回收机制" class="headerlink" title="Python垃圾回收机制"></a>Python垃圾回收机制</h4><p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。<br>在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p><ol><li>引用计数<br>PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。</li><li>标记-清除机制<br>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</li><li>分代技术<br>整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</li></ol><h4 id="Python的is"><a href="#Python的is" class="headerlink" title="Python的is"></a>Python的is</h4><p><code>is</code>是对比地址，<code>==</code>是对比值</p><h4 id="read，readline和readlines"><a href="#read，readline和readlines" class="headerlink" title="read，readline和readlines"></a>read，readline和readlines</h4><ul><li><code>read</code> 读取整个文件</li><li><code>readline</code> 读取下一行,使用生成器方法</li><li><code>readlines</code> 读取整个文件到一个迭代器以供我们遍历</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习python，总结了下python常用的知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
</feed>
