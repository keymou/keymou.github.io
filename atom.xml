<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Үміт</title>
  
  <subtitle>心有猛虎，細嗅薔薇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.keymou.wang/"/>
  <updated>2018-12-29T06:45:49.311Z</updated>
  <id>https://www.keymou.wang/</id>
  
  <author>
    <name>keymou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 模拟 Ajax 请求抓取新浪微博</title>
    <link href="https://www.keymou.wang/Python%E6%A8%A1%E6%8B%9FAjax%E8%AF%B7%E6%B1%82%E6%8A%93%E5%8F%96%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A.html"/>
    <id>https://www.keymou.wang/Python模拟Ajax请求抓取新浪微博.html</id>
    <published>2018-12-29T03:19:58.000Z</published>
    <updated>2018-12-29T06:45:49.311Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Python 模拟Ajax 请求，抓取新浪微博。</p><a id="more"></a><blockquote><h4 id="Ajax是什么"><a href="#Ajax是什么" class="headerlink" title="Ajax是什么"></a>Ajax是什么</h4></blockquote><p>全称为 Asynchronous JavaScript and XML，即异步的 JavaScript 和 XML，利用 JavaScript 在保证页面不被刷新、页面链接不变的情况下与服务器交换数据并更新部分网页的技术。</p><p>拿新浪微博为例，打开我的微博链接  <a href="https://m.weibo.cn/u/1715175570" target="_blank" rel="noopener">https://m.weibo.cn/u/1715175570</a> ，一直下滑，可以发现下滑几个微博之后，会出现一个加载的动画，不一会儿就继续出现了新的微博内容，这个过程其实就是 Ajax 加载的过程。</p><blockquote><p>Ajax 基本原理 </p></blockquote><p>这里不多做介绍，详细可参考 W3school 关于 <a href="http://www.w3school.com.cn/ajax/index.asp" target="_blank" rel="noopener">Ajax 教程</a></p><blockquote><h4 id="分析请求"><a href="#分析请求" class="headerlink" title="分析请求"></a>分析请求</h4></blockquote><p>用Firefox浏览器打开我的微博链接 <a href="https://m.weibo.cn/u/1715175570" target="_blank" rel="noopener">https://m.weibo.cn/u/1715175570</a> ，打开火狐浏览器自带的 Web 开发者工具，切换“网络”选项卡，可以发现这里出现很多条请求。Ajax 的请求类型是 xhr，可以通过工具栏上不同请求类型如 HTML、CSS、JS、XHR 等过滤请求。</p><p>点击”XHR“ 类型，过滤出 Ajax 请求再做分析。点击其中一条，可以查询该条请求的详细。在“消息头”选项卡中查看 请求网址，请求方法，以及请求头的详细，<code>X-Requested-With</code> 是 <code>XMLHttpRequest</code>，这就标记了此请求是 Ajax 请求。</p><p>随后可点击下 ”响应“，可以看到 JSON 格式的响应内容，返回的是个人信息，如昵称、简介等，这也是用来渲染个人主页所用的数据。</p><p>下滑页面以加载新的微博内容，可以看到，会有不断的 Ajax 请求发出。选择其中一个请求，分析它的参数信息。</p><p>这是一个 GET 请求，请求链接是 </p><p><a href="https://m.weibo.cn/api/container/getIndex?type=uid&amp;value=1715175570&amp;containerid=1076031715175570&amp;page=2" target="_blank" rel="noopener">https://m.weibo.cn/api/container/getIndex?type=uid&amp;value=1715175570&amp;containerid=1076031715175570&amp;page=2</a> 。</p><p>请求的参数有 4 个：type、value、containerid、page。</p><p>继续看接下来的请求，可以发现，type、value、containerid 始终没有变化，改变的值只有 page，很明显这个参数用来控制分页的，下图所示。</p><p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fynhopj0vxg21fe0dje81.jpg" alt="Ajax请求分析"></p><blockquote><h4 id="分析响应"><a href="#分析响应" class="headerlink" title="分析响应"></a>分析响应</h4></blockquote><p>观察这个请求的响应内容，所图所示：</p><p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fynignltl8j216n0l8wf3.jpg" alt="response"></p><p>响应内容是 JSON 格式的，data 数据分为两部分：cardlilstInfo、cards。cards 是一个列表，包含要提取的微博信息，比较重要的字段是 mblog。 包含的是微博一些信息，如 created_at（发布日期）、reposts_count（转发数目）、comments_count（评论数目）、attitudes_count（点赞数目）、text（微博正文）等。</p><p>这样可以请求一个接口，就可以获得一个 page 的微博，只需改变参数 page 即可。</p><blockquote><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4></blockquote><p>可以先定义一个获取单个 page 的函数 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">'Host'</span>: <span class="string">'m.weibo.cn'</span>,</span><br><span class="line">        <span class="string">'Referer'</span>: <span class="string">'https://m.weibo.cn/u/1715175570'</span>,</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0;) Gecko/20100101 Firefox/63.0'</span>,</span><br><span class="line">        <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(page)</span>:</span></span><br><span class="line">    <span class="string">"""获取页面page微博列表"""</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">'type'</span>:<span class="string">'uid'</span>,</span><br><span class="line">        <span class="string">'value'</span>: <span class="string">'1715175570'</span>,</span><br><span class="line">        <span class="string">'containerid'</span>: <span class="string">'1076031715175570'</span>,</span><br><span class="line">        <span class="string">'page'</span>: page</span><br><span class="line">    &#125;</span><br><span class="line">    url = base_url + urlencode(params)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.json()</span><br><span class="line">    <span class="keyword">except</span> requests.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'Error'</span>, e.args)</span><br></pre></td></tr></table></figure><p>这里定义 base_url 来表示请求的 URL 前半部分，接下来，构造参数字典，调用 urlencode() 方法将参数转换成 URL 的 GET 请求参数。随后，base_url 与参数拼接成完整的 URL 。</p><p>用 requests 请求这个链接，加入 headers 参数，然后判断响应的状态码，若请求成功，返回 200，则调用 json() 方法将内容解析为 JSON 返回，否则不返回任何信息。</p><p>之后定义一个解析方法 parse_page(json)，用来从返回的 JSON 中提取信息，遍历 cards，获取 mblog 中的各个信息，赋值为一个信息的字典返回即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(json)</span>:</span></span><br><span class="line">    <span class="string">"""解析网页"""</span></span><br><span class="line">    <span class="keyword">if</span> json:</span><br><span class="line">        items = json.get(<span class="string">'data'</span>).get(<span class="string">'cards'</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            item = item.get(<span class="string">'mblog'</span>)</span><br><span class="line">            weibo = &#123;&#125;</span><br><span class="line">            <span class="comment"># 发布日期</span></span><br><span class="line">            weibo[<span class="string">'date'</span>] = item.get(<span class="string">'created_at'</span>)</span><br><span class="line">            weibo[<span class="string">'id'</span>] = item.get(<span class="string">'id'</span>)</span><br><span class="line">            <span class="comment"># 微博正文</span></span><br><span class="line">            weibo[<span class="string">'text'</span>] = pq(item.get(<span class="string">'text'</span>)).text()</span><br><span class="line">            weibo[<span class="string">'source'</span>] = item.get(<span class="string">'source'</span>)</span><br><span class="line">            <span class="comment"># 转发数</span></span><br><span class="line">            weibo[<span class="string">'reposts'</span>] = item.get(<span class="string">'reposts_count'</span>)</span><br><span class="line">            <span class="comment"># 评论数</span></span><br><span class="line">            weibo[<span class="string">'comments'</span>] = item.get(<span class="string">'comments_count'</span>)</span><br><span class="line">            <span class="comment"># 点赞数</span></span><br><span class="line">            weibo[<span class="string">'attitudes'</span>] = item.get(<span class="string">'attitudes_count'</span>)</span><br><span class="line">            <span class="keyword">yield</span> weibo</span><br></pre></td></tr></table></figure><p>然后再定义一个方法将解析出来的结果储存到 MongoDB 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_mongo</span><span class="params">(result)</span>:</span></span><br><span class="line">    <span class="string">"""将返回结果result保存到MongoDB"""</span></span><br><span class="line">    <span class="keyword">if</span> collection.insert_many(result):</span><br><span class="line">        print(<span class="string">'Saved to mongodb'</span>)</span><br></pre></td></tr></table></figure><p>另外定义一个获取长微博全文内容的方法，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longtext</span><span class="params">(id)</span>:</span></span><br><span class="line">    <span class="string">"""获取长微博内容"""</span></span><br><span class="line">    url = <span class="string">'https://m.weibo.cn/statuses/extend?id='</span> + id</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            longtext = response.json().get(<span class="string">'data'</span>).get(<span class="string">'longTextContent'</span>)</span><br><span class="line">            <span class="keyword">return</span> pq(longtext).text()</span><br><span class="line">    <span class="keyword">except</span> requests.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'Error'</span>, e.args)</span><br></pre></td></tr></table></figure><p>需要传入一个 id 参数，配合改写下解析方法parse_page(json)，整合代码，完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(json)</span>:</span></span><br><span class="line">    <span class="string">"""解析网页"""</span></span><br><span class="line">    <span class="keyword">if</span> json:</span><br><span class="line">        items = json.get(<span class="string">'data'</span>).get(<span class="string">'cards'</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                item = item.get(<span class="string">'mblog'</span>)</span><br><span class="line">                weibo = &#123;&#125;</span><br><span class="line">                <span class="comment"># 创建日期</span></span><br><span class="line">                weibo[<span class="string">'date'</span>] = item.get(<span class="string">'created_at'</span>)</span><br><span class="line">                weibo[<span class="string">'id'</span>] = item.get(<span class="string">'id'</span>)</span><br><span class="line">                <span class="comment"># 判断是否为长微博</span></span><br><span class="line">                <span class="keyword">if</span> item.get(<span class="string">'isLongText'</span>) == <span class="keyword">True</span>:</span><br><span class="line">                    content = pq(item.get(<span class="string">'text'</span>))</span><br><span class="line">                    result = re.search(<span class="string">r'&lt;a.*?status.*?(\d&#123;16&#125;).*?"'</span>, str(content))</span><br><span class="line">                    lt_id = result.group(<span class="number">1</span>)</span><br><span class="line">                    weibo[<span class="string">'text'</span>] = longtext(lt_id)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 微博正文</span></span><br><span class="line">                    weibo[<span class="string">'text'</span>] = pq(item.get(<span class="string">'text'</span>)).text()</span><br></pre></td></tr></table></figure><p>修改下 get_page() 方法，将 value、containerid 同样做了参数化处理，这样可以方便爬取其他微博用户的信息。值得注意的是，返回的 JSON 内容在遍历 cards时可能会报错，原因在于微博有时会在 cards 列表中返回博主关注的信息，导致在解析时报 AttributeError，故在parse_page() 方法加上异常处理、以及抓取了转发微博的原微博内容。</p><p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fynj8iw07qj20wi0h5n0p.jpg" alt=""></p><p>最后在 main() 中通过 while 循环实现遍历所有页的微博内容。</p><blockquote><h5 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h5></blockquote><p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fynltrbs13j20pz098mx9.jpg" alt="执行结果"></p><p>Studio 3T客户端展示结果如下：</p><p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fynlsezjtfj21h00kp75l.jpg" alt="Studio 3T展示结果"></p><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">获取微博</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(value, containerid, page)</span>:</span></span><br><span class="line">    <span class="string">"""获取页面微博列表"""</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">'type'</span>:<span class="string">'uid'</span>,</span><br><span class="line">        <span class="string">'value'</span>: value,</span><br><span class="line">        <span class="string">'containerid'</span>: containerid,</span><br><span class="line">        <span class="string">'page'</span>: page</span><br><span class="line">    &#125;</span><br><span class="line">    url = base_url + urlencode(params)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.json()</span><br><span class="line">    <span class="keyword">except</span> requests.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'Error'</span>, e.args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(json)</span>:</span></span><br><span class="line">    <span class="string">"""解析网页"""</span></span><br><span class="line">    <span class="keyword">if</span> json:</span><br><span class="line">        items = json.get(<span class="string">'data'</span>).get(<span class="string">'cards'</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                item = item.get(<span class="string">'mblog'</span>)</span><br><span class="line">                weibo = &#123;&#125;</span><br><span class="line">                <span class="comment"># 创建日期</span></span><br><span class="line">                weibo[<span class="string">'date'</span>] = item.get(<span class="string">'created_at'</span>)</span><br><span class="line">                weibo[<span class="string">'id'</span>] = item.get(<span class="string">'id'</span>)</span><br><span class="line">                <span class="comment"># 判断是否为长微博</span></span><br><span class="line">                <span class="keyword">if</span> item.get(<span class="string">'isLongText'</span>) == <span class="keyword">True</span>:</span><br><span class="line">                    content = pq(item.get(<span class="string">'text'</span>))</span><br><span class="line">                    result = re.search(<span class="string">r'&lt;a.*?status.*?(\d&#123;16&#125;).*?"'</span>, str(content))</span><br><span class="line">                    lt_id = result.group(<span class="number">1</span>)</span><br><span class="line">                    weibo[<span class="string">'text'</span>] = longtext(lt_id)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 微博正文</span></span><br><span class="line">                    weibo[<span class="string">'text'</span>] = pq(item.get(<span class="string">'text'</span>)).text()</span><br><span class="line">                weibo[<span class="string">'source'</span>] = item.get(<span class="string">'source'</span>)</span><br><span class="line">                <span class="comment"># 转发数</span></span><br><span class="line">                weibo[<span class="string">'reposts'</span>] = item.get(<span class="string">'reposts_count'</span>)</span><br><span class="line">                <span class="comment"># 评论数</span></span><br><span class="line">                weibo[<span class="string">'comments'</span>] = item.get(<span class="string">'comments_count'</span>)</span><br><span class="line">                <span class="comment"># 点赞数</span></span><br><span class="line">                weibo[<span class="string">'attitudes'</span>] = item.get(<span class="string">'attitudes_count'</span>)</span><br><span class="line">                <span class="comment"># 转发原文内容</span></span><br><span class="line">                <span class="keyword">if</span> item.get(<span class="string">'retweeted_status'</span>):</span><br><span class="line">                    weibo[<span class="string">'repost_text'</span>] = pq(item.get(<span class="string">'retweeted_status'</span>).get(<span class="string">'text'</span>)).text()</span><br><span class="line">            <span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">yield</span> weibo</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longtext</span><span class="params">(id)</span>:</span></span><br><span class="line">    <span class="string">"""获取长微博内容"""</span></span><br><span class="line">    url = <span class="string">'https://m.weibo.cn/statuses/extend?id='</span> + id</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            longtext = response.json().get(<span class="string">'data'</span>).get(<span class="string">'longTextContent'</span>)</span><br><span class="line">            <span class="comment"># 通过pyquery方法去掉一些html标签</span></span><br><span class="line">            <span class="keyword">return</span> pq(longtext).text()</span><br><span class="line">    <span class="keyword">except</span> requests.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'Error'</span>, e.args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_mongo</span><span class="params">(result)</span>:</span></span><br><span class="line">    <span class="string">"""将返回结果result保存到MongoDB"""</span></span><br><span class="line">    <span class="keyword">if</span> collection.insert_many(result):</span><br><span class="line">        print(<span class="string">'Saved to mongodb'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    value = <span class="string">'1862855661'</span></span><br><span class="line">    containerid = <span class="string">'1076031862855661'</span></span><br><span class="line">    base_url = <span class="string">'https://m.weibo.cn/api/container/getIndex?'</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'Host'</span>: <span class="string">'m.weibo.cn'</span>,</span><br><span class="line">        <span class="string">'Referer'</span>: <span class="string">'https://m.weibo.cn/u/'</span> + value,</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0;) Gecko/20100101 Firefox/63.0'</span>,</span><br><span class="line">        <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span></span><br><span class="line">    &#125;</span><br><span class="line">    myclient = MongoClient(<span class="string">"mongodb://localhost:27017/"</span>)</span><br><span class="line">    mydb = myclient[<span class="string">"test"</span>]</span><br><span class="line">    collection = mydb[<span class="string">"weibo"</span> + value]</span><br><span class="line">    page = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(<span class="string">'*'</span>*<span class="number">50</span>)</span><br><span class="line">        print(<span class="string">'正在爬取：第%s 页'</span> %page)</span><br><span class="line">        json = get_page(value, containerid, page)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> json.get(<span class="string">'ok'</span>) == <span class="number">0</span>:</span><br><span class="line">            results = parse_page(json)</span><br><span class="line">            save_to_mongo(results)</span><br><span class="line">            page += <span class="number">1</span></span><br><span class="line">            time.sleep(random.randint(<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"下载完最后一页!"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>本文完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 模拟Ajax 请求，抓取新浪微博。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.keymou.wang/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python爬虫" scheme="https://www.keymou.wang/tags/python%E7%88%AC%E8%99%AB/"/>
    
      <category term="MongoDB" scheme="https://www.keymou.wang/tags/MongoDB/"/>
    
      <category term="Ajax" scheme="https://www.keymou.wang/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>requests库抓取猫眼电影排行</title>
    <link href="https://www.keymou.wang/requests%E5%BA%93%E6%8A%93%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8E%92%E8%A1%8C.html"/>
    <id>https://www.keymou.wang/requests库抓取猫眼电影排行.html</id>
    <published>2018-12-26T02:18:58.000Z</published>
    <updated>2018-12-26T03:48:33.568Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>通过requests库，正则表达式抓取分析猫眼榜单100 并保存到MongoDB。</p><a id="more"></a><p>【摘要】：最近在学习爬虫，阅读崔大大的《Python 3网络爬虫开发实战》一书，获益匪浅。第一个爬虫实战就是抓取猫眼电影榜单100。</p><p>这里简单介绍下如何分析源代码，通过正则表达式爬取数据并保存到数据库。</p><h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><p>确保已安装好 request 库，pymongo库，配置好 MongoDB 。</p><h5 id="抓取分析"><a href="#抓取分析" class="headerlink" title="抓取分析"></a>抓取分析</h5><p>抓取的目标站点是  <a href="https://maoyan.com/board/4" target="_blank" rel="noopener">https://maoyan.com/board/4</a> ，排名第一的电影是霸王别姬，页面中显示的有效信息有影片名称、主演、上映时间、上映地区、评分、海报等信息。</p><p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fyjy4zypq7j21hc0swaj3.jpg" alt="猫眼电影榜单"></p><p>翻页到第二页，显示的结果是排行11~20 的电影，URL 变成 <a href="https://maoyan.com/board/4?offset=10" target="_blank" rel="noopener">https://maoyan.com/board/4?offset=10</a> ，URL比之前多了一个offset 的参数，继续翻页，显示的结果是排行21~30 的电影，URL 变为 <a href="https://maoyan.com/board/4?offset=20" target="_blank" rel="noopener">https://maoyan.com/board/4?offset=20</a> </p><p>总结规律：URL 中参数 offset 代表偏移量值，如果偏移量为n ，则显示的电影序号就是n+1 到n+10, 每页显示10 个。获取 TOP100 电影，则分开请求10 次即可。</p><h5 id="抓取单页面"><a href="#抓取单页面" class="headerlink" title="抓取单页面"></a>抓取单页面</h5><p>首先抓取单个页面信息，定义一个 get_one_page()方法，具体代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">抓取猫眼电影榜单</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_one_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="string">"""获取url的电影信息"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ua = UserAgent()</span><br><span class="line">        headers = &#123;</span><br><span class="line">        <span class="comment"># 引用fake_useragent随机生成一个User-Agent</span></span><br><span class="line">            <span class="string">'User-Agent'</span>: ua.random</span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">except</span> RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="string">""" """</span></span><br><span class="line">url = <span class="string">'https://maoyan.com/board/4'</span></span><br><span class="line">html = get_one_page(url)</span><br><span class="line">print(html)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h5 id="正则提取电影信息"><a href="#正则提取电影信息" class="headerlink" title="正则提取电影信息"></a>正则提取电影信息</h5><p>要获取页面影片名称、主演、上映时间、上映地区、评分、海报等信息，分析页面源码，利用Web 开发者工具，查看“网络”-“响应”，获取到response 源代码。</p><p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fyjyupykauj21hc0swgqy.jpg" alt=""></p><p>分析其中一个条目，可以看到，一部电影信息对应的源代码是一个dd 节点，我们用正则表达式来提取这里面的一些电影信息。首先，需要提取它的排名信息。排名位于 class 为 board-index 的 i 节点内，正则表达式写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;&lt;dd&gt;.*?board-index-.*?&gt;(.*?)&lt;/i&gt;</span><br></pre></td></tr></table></figure><p>随后提取电影的海报信息，后面有a 节点，其内部有两个img 节点。分别尝试打开两个 img 链接，第二个 img 节点data-src 属性是海报的链接。 提取第二个img 节点的data-src 属性，正则表达式改写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dd&gt;.*?board-index-.*?&gt;(.*?)&lt;/i&gt;.*?data-src=&quot;(.*?)&quot;</span><br></pre></td></tr></table></figure><p>再往后，依次提取电影的名称、主演、发布时间、评分等内容，最终的正则表达式写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dd&gt;.*?board-index-.*?&gt;(.*?)&lt;/i&gt;.*?data-src=&quot;(.*?)&quot;.*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;</span><br></pre></td></tr></table></figure><p>接下来通过调用 <code>findall</code>方法提取出所有的内容。</p><p>实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one_page</span><span class="params">(html)</span>:</span></span><br><span class="line">    <span class="string">"""解析单页电影信息"""</span></span><br><span class="line">    pattern = re.compile(<span class="string">r'&lt;dd&gt;.*?board-index-.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;'</span>, re.S)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line">    <span class="comment"># 遍历提取结果，去掉提取结果中不必要的信息（主演、上映时间）并生成字典</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">'index'</span>: item[<span class="number">0</span>],</span><br><span class="line">            <span class="string">'image'</span>: item[<span class="number">1</span>],</span><br><span class="line">            <span class="string">'title'</span>: item[<span class="number">2</span>].strip(),            </span><br><span class="line">            <span class="string">'actor'</span>: item[<span class="number">3</span>].strip()[<span class="number">3</span>:] <span class="keyword">if</span> len(item[<span class="number">3</span>]) &gt; <span class="number">3</span> <span class="keyword">else</span> <span class="string">''</span>,</span><br><span class="line">            <span class="string">'time'</span>: item[<span class="number">4</span>].strip()[<span class="number">5</span>:] <span class="keyword">if</span> len(item[<span class="number">4</span>]) &gt; <span class="number">5</span> <span class="keyword">else</span> <span class="string">''</span>,</span><br><span class="line">            <span class="string">'score'</span>: item[<span class="number">5</span>].strip() + item[<span class="number">6</span>].strip()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="写入MongoDB数据"><a href="#写入MongoDB数据" class="headerlink" title="写入MongoDB数据"></a>写入MongoDB数据</h5><p>实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_mongodb</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">"""写入MongoDB数据库"""</span></span><br><span class="line">    <span class="comment"># 创建数据库需要使用 MongoClient 对象，并且指定连接的 URL 地址和要创建的数据库名。</span></span><br><span class="line">    myclient = pymongo.MongoClient(<span class="string">"mongodb://localhost:27017/"</span>)</span><br><span class="line">    <span class="comment"># 创建数据库test和集合collections，注意使用[]</span></span><br><span class="line">    mydb = myclient[<span class="string">"test"</span>]</span><br><span class="line">    mycol = mydb[<span class="string">"top100"</span>]</span><br><span class="line">    mycol.insert_one(data)</span><br></pre></td></tr></table></figure><h5 id="代码整合"><a href="#代码整合" class="headerlink" title="代码整合"></a>代码整合</h5><p>实现<code>main()</code>方法来调用前面实现的方法，将单页的电影结果写入到数据库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""main()"""</span></span><br><span class="line">    url = <span class="string">'https://maoyan.com/board/4'</span></span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> parse_one_page(html):</span><br><span class="line">        write_to_mongodb(item)</span><br></pre></td></tr></table></figure><h5 id="分页爬取"><a href="#分页爬取" class="headerlink" title="分页爬取"></a>分页爬取</h5><p>因为我们需要抓取的是TOP100 的电影，所以还需要遍历一下，给这个链接传入offset 参数，实现其他90 部电影的爬取，此时添加如下调用即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        main(offset=i*<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>对应的修改下<code>main()</code>函数，接收一个offset 值作为偏移量，然后构造URL 进行爬取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset)</span>:</span></span><br><span class="line">    <span class="string">"""main()"""</span></span><br><span class="line">    url = <span class="string">'https://maoyan.com/board/4?offset='</span>+ str(offset)</span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> parse_one_page(html):</span><br><span class="line">        write_to_mongodb(item)</span><br></pre></td></tr></table></figure><h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p>电影榜单TOP100 成功保存到 MongoDB 数据库中。</p><p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fyjzkk1dq9j21b70oa76q.jpg" alt=""></p><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">抓取猫眼电影排行</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">import re</span><br><span class="line">import time</span><br><span class="line">import pymongo</span><br><span class="line">import requests</span><br><span class="line">from requests.exceptions import RequestException</span><br><span class="line">from fake_useragent import UserAgent</span><br><span class="line"></span><br><span class="line">def get_one_page(url):</span><br><span class="line">    &quot;&quot;&quot;获取url的电影信息&quot;&quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        ua = UserAgent()</span><br><span class="line">        headers = &#123;</span><br><span class="line">        # 引用fake_useragent随机生成一个User-Agent</span><br><span class="line">            &apos;User-Agent&apos;: ua.random</span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        if response.status_code == 200:</span><br><span class="line">            return response.text</span><br><span class="line">        return None</span><br><span class="line">    except RequestException:</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">def parse_one_page(html):</span><br><span class="line">    &quot;&quot;&quot;解析单页电影信息&quot;&quot;&quot;</span><br><span class="line">    pattern = re.compile(r&apos;&lt;dd&gt;.*?board-index-.*?&gt;(.*?)&lt;/i&gt;.*?data-src=&quot;(.*?)&quot;.*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;&apos;, re.S)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line">    for item in items:</span><br><span class="line">        yield &#123;</span><br><span class="line">            &apos;index&apos;: item[0],</span><br><span class="line">            &apos;image&apos;: item[1],</span><br><span class="line">            &apos;title&apos;: item[2].strip(),</span><br><span class="line">            &apos;actor&apos;: item[3].strip()[3:] if len(item[3]) &gt; 3 else &apos;&apos;,</span><br><span class="line">            &apos;time&apos;: item[4].strip()[5:] if len(item[4]) &gt; 5 else &apos;&apos;,</span><br><span class="line">            &apos;score&apos;: item[5].strip() + item[6].strip()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def write_to_mongodb(data):</span><br><span class="line">    &quot;&quot;&quot;写入MongoDB数据库&quot;&quot;&quot;</span><br><span class="line">    # 创建数据库需要使用 MongoClient 对象，并且指定连接的 URL 地址和要创建的数据库名。</span><br><span class="line">    myclient = pymongo.MongoClient(&quot;mongodb://localhost:27017/&quot;)</span><br><span class="line">    # 创建数据库test和集合collections，注意使用[]</span><br><span class="line">    mydb = myclient[&quot;test&quot;]</span><br><span class="line">    mycol = mydb[&quot;top100&quot;]</span><br><span class="line">    mycol.insert_one(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main(offset):</span><br><span class="line">    &quot;&quot;&quot;main()&quot;&quot;&quot;</span><br><span class="line">    url = &apos;https://maoyan.com/board/4?offset=&apos;+ str(offset)</span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    for item in parse_one_page(html):</span><br><span class="line">        write_to_mongodb(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    for i in range(10):</span><br><span class="line">        main(offset=i*10)</span><br><span class="line">        # 每请求一次，增加了一个延时等待，防止请求过快</span><br><span class="line">        time.sleep(1.5)</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://item.jd.com/12333540.html" target="_blank" rel="noopener">《Python 3网络爬虫开发实战 ,崔庆才著》</a> <a href="http://www.runoob.com/python3/python-mongodb.html" target="_blank" rel="noopener">Python Mongodb</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过requests库，正则表达式抓取分析猫眼榜单100 并保存到MongoDB。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.keymou.wang/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python爬虫" scheme="https://www.keymou.wang/tags/python%E7%88%AC%E8%99%AB/"/>
    
      <category term="MongoDB" scheme="https://www.keymou.wang/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>tesserocr解析库</title>
    <link href="https://www.keymou.wang/tesserocr%E8%A7%A3%E6%9E%90%E5%BA%93.html"/>
    <id>https://www.keymou.wang/tesserocr解析库.html</id>
    <published>2018-12-21T14:16:44.000Z</published>
    <updated>2018-12-22T02:23:47.073Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>OCR，即Optical Character Recognition，光学字符识别。</p><a id="more"></a><p>是指通过扫描字符，然后通过其形状将其翻译成电子文本的过程。对于图形验证码来说，它们都是一些不规则的字符，这些字符确实是由字符稍加扭曲变换得到的内容。</p><p>tesserocr 是 Python 的一个OCR 识别库，但其实是对 tesseract 做的一层Python API 封装，所以它的核心是 tesseract 。在安装 tesserocr 之前，需要先安装 tesseract。</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><ul><li>tesserocr GitHub：<a href="https://github.com/sirfz/tesserocr" target="_blank" rel="noopener">https://github.com/sirfz/tesserocr</a></li><li>tesserocr PyPI：<a href="https://pypi.python.org/pypi/tesserocr" target="_blank" rel="noopener">https://pypi.python.org/pypi/tesserocr</a></li><li>tesseract 下载地址：<a href="https://digi.bib.uni-mannheim.de/tesseract/" target="_blank" rel="noopener">https://digi.bib.uni-mannheim.de/tesseract/</a></li><li>tesseract GitHub：<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata</a></li><li>tesseract 语言包：<a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tessdata</a></li></ul><h4 id="tesseract"><a href="#tesseract" class="headerlink" title="tesseract"></a>tesseract</h4><p>下载地址 <a href="https://digi.bib.uni-mannheim.de/tesseract/" target="_blank" rel="noopener">https://digi.bib.uni-mannheim.de/tesseract/</a> </p><ul><li>带有 dev 的为开发版本</li><li>带alpha 的为内部测试版本</li><li>带beta 的为公开测试版</li><li>带 rc 的为Release Candidate（候选版本）</li><li>其他为稳定版本，推荐选择 tesseract-3.05 的稳定版本。</li></ul><p>下载完成后双击，可以勾选 Additional language data ( download）选项来安装OCR 识别支持的语言包，这样OCR便可以识别多国语言，然后一路默认，点击 Next 按钮即可。</p><p>不建议勾选Additional language data ( download）选项，因为速度比较慢，可以安装后直接下载语言包，然后将语言包复制到安装目录的 tessdata 目录下即可。</p><h4 id="tesserocr"><a href="#tesserocr" class="headerlink" title="tesserocr"></a>tesserocr</h4><p>使用命令：</p><p><code>pip install tesserocr pillow</code></p><p>若安装报错，提示信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: Microsoft Visual C++ 14.0 is required. Get it with &quot;Microsoft Visual C++ Build Tools&quot;: https://visualstudio.microsoft.com/downloads/</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>下载对应版本的whl 包（和下载的tesseract 版本对应），</p><p>地址：<a href="https://github.com/simonflueckiger/tesserocr-windows_build/releases" target="_blank" rel="noopener">https://github.com/simonflueckiger/tesserocr-windows_build/releases</a> ，</p><p>然后使用命令行安装：</p><p><code>pip install &lt;package_name&gt;.whl</code></p><h4 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h4><p>以如下面所示的图片为样例进行测试。</p><p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fyerbdehzpj20gw032mxd.jpg" alt="测试图片"></p><p>首先使用命令行进行测试，使用 tesseract 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Keymou\Desktop</span><br><span class="line">λ tesseract image.png result -l eng &amp;&amp; cat result.txt</span><br><span class="line">Tesseract Open Source OCR Engine v3.05.02 with Leptonica</span><br><span class="line">Python3WebSpider</span><br></pre></td></tr></table></figure><p>其中第一个参数为图片名称，第二个参数result 为结果保存的目标文件名称，-l  指定使用的语言包，在此使用英文（ eng ）。然后，再用cat 命令将结果输出。</p><p>运行结果便是图片的识别结果：Python3WebSpider。</p><p><code>tesseract imagename|stdin outputbase|stdout [options...] [configfile...]</code></p><p>用Python 代码来测试，借助于 tesserocr 库。</p><p>测试代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import tesserocr</span><br><span class="line">from PIL import Image</span><br><span class="line">image = Image.open(r&apos;D:\\python\\image.png&apos;)</span><br><span class="line">print(tesserocr.image_to_text(image))</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p>Python3WebSpider</p><p>或者 直接在 cmd 中 直接调用 file_to_text()方法，代码过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">λ python</span><br><span class="line">Python 3.7.0 (default, Jun 28 2018, 08:04:48) [MSC v.1912 64 bit (AMD64)] :: Anaconda, Inc. on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import tesserocr</span><br><span class="line">&gt;&gt;&gt; print(tesserocr.file_to_text(&apos;image.png&apos;))</span><br><span class="line">Python3WebSpider</span><br></pre></td></tr></table></figure><p>推荐一个颜值很高的 cmd 工具，Cmder。</p><p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fyerwyzcc2j20q50cqjuf.jpg" alt="Cmder"></p><p>如果成功输出结果，则证明 tesseract 和 tesserocr 都已经安装成功。</p><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><p>安装 tesserocr 折腾了很久，安装过程或许会碰到意外情况，不要慌，首先上网搜索看看，是否能解决，根据实际情况排查解决问题。</p><p>常见报错信息： <code>RuntimeError: Failed to init API, possibly an invalid tessdata path: D:\ProgramData\Anaconda3\</code></p><p>分析错误信息，是初始化API 失败，可能是一个无效的tessdata 路径。检查下后面给出path 下是否有 tessdata 目录。</p><ol><li>第一种情况，没有该目录，则需要新建目录，然后将 tesseract 安装目录下的tessdata 复制该path 下。若提示的path 存在并且已经有tessdata 目录，就需要检查下是否环境变量没有配置。新增环境变量 TESSDATA_PREFIX，变量值为 指向 tessdata 的路径，如 C:\Tesseract-OCR\tessdata</li><li>第二种情况，path目录下存在 tessdata，环境变量也已生效，但python 代码测试时仍报 API 初始化错误，可能需要考虑是否版本问题。我折腾了很久，安装的 tesseract 4.0，但一直报错，换成tesseract-3.05，问题解决。</li></ol><p>python3 通过Anaconda3 安装的，可以通过以下命令试安装：</p><p><code>&gt; conda install -c simonflueckiger tesserocr</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OCR，即Optical Character Recognition，光学字符识别。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.keymou.wang/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python爬虫" scheme="https://www.keymou.wang/tags/python%E7%88%AC%E8%99%AB/"/>
    
      <category term="tesserocr" scheme="https://www.keymou.wang/tags/tesserocr/"/>
    
  </entry>
  
  <entry>
    <title>软件开发生命周期</title>
    <link href="https://www.keymou.wang/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"/>
    <id>https://www.keymou.wang/软件开发生命周期.html</id>
    <published>2018-12-18T08:17:32.000Z</published>
    <updated>2018-12-20T00:16:39.948Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算机行业流行一个笑话：有三样东西在制造过程中是永远看不见的——法律、香肠和软件。</p><a id="more"></a> <p>这种说法不完全对，但有些软件开发严格有序，有些软件控制却混乱不堪。软件产品从最初构思到公开发行的过程称为<em>软件开发生命周期模式。</em></p><p>以下是常用的模式：</p><ol><li><p><strong>大爆炸模式</strong></p><p>最简单的软件开发模式，优点是简单。计划、进度安排和正规开发过程几乎没有，所有精力花费在开发软件和编写代码上。</p></li><li><p><strong>编写边改模式</strong></p><p>通常只有粗略的想法，进行一些简单的设计，然后开始漫长的来回编写、测试和修改缺陷的过程，反复直到觉得足够了，就发布产品。</p></li><li><p><strong>瀑布模式</strong></p><p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fycwapz4hyj20f809a3zp.jpg" alt="瀑布模式"></p><p>最典型的预见性的方法，严格遵循预先计划的需求分析、设计、编码、集成、测试、维护的步骤顺序进行。<br>步骤成果作为衡量进度的方法，例如需求规格，设计文档，测试计划和代码审阅等等。 </p><p>瀑布式的主要的问题是它的严格分级导致的自由度降低，项目早期即作出承诺导致对后期需求的变化难以调整，代价高昂。瀑布式方法在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。  </p></li><li><p><strong>螺旋模式</strong></p><p>核心就在于不需要在刚开始的时候就把所有事情都定义的清清楚楚。轻松上阵，定义最重要的功能，实现它，然后听取客户的意见，之后再进入到下一个阶段。</p><p>螺旋模式每一次循环包括6个步骤：</p><p>1）明确目标、可选方案和限制条件。</p><p>2）明确并化解风险。</p><p>3）评估可选方案。</p><p>4）当前阶段的开发和测试。</p><p>5）计划下一阶段。</p><p>6）确定进入下一阶段的方法。</p><p>螺旋模型很大程度上是一种风险驱动的方法体系，因为在每个阶段之前及经常发生的循环之前，都必须首先进行风险评估。</p></li><li><p><strong>迭代式开发</strong></p><p>也被称作<strong>迭代增量式开发</strong>或<strong>迭代进化式开发</strong>，是一种与传统的瀑布式开发相反的软件开发过程，它弥补了传统开发方式中的一些弱点，具有更高的成功率和生产率。</p><p>每次只设计和实现这个产品的一部分，逐步逐步完成的方法叫迭代开发，每次设计和实现一个阶段叫做一个迭代。</p><p>在迭代开发方法中，每一次迭代都包括了需求分析、设计、实现与测试。采用这种方法，开发工作可以在需求被完整地确定之前启动，并在一次迭代中完成系统的一部分功能或业务逻辑的开发工作。再通过客户的反馈来细化需求，并开始新一轮的迭代。</p><p>迭代式开发的优点：<br>　　1、降低风险<br>　　2、得到早期用户反馈<br>　　3、持续的测试和集成<br>　　4、使用变更<br>　　5、提高复用性</p></li></ol><p>   <strong>敏捷软件开发</strong></p><p>   又称<strong>敏捷开发</strong>，是一种应对快速变化的需求的一种软件开发能力。更强调程序员团队与业务专家之间的紧密协作、面对面的沟通、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发中人的作用。</p><p>   敏捷开发的目的：</p><blockquote><p>通过过程和工具理解个人和交流的作用</p><p>通过全面的文档理解运行的软件</p><p>通过合同和谈判得到客户的协作</p><p>在计划的执行中做出对变更的响应</p></blockquote><p>   迭代开发是<strong>一种</strong>软件开发的<strong>生命周期模型</strong>，敏捷开发是多种软件开发项目管理方法的集合，其中包括了XP、Scrum等，简单来说，<strong>迭代式开发模型是敏捷开发普遍使用的软件生命周期模型</strong>，<strong>敏捷开发所包含的内容比迭代模型宽泛的多</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机行业流行一个笑话：有三样东西在制造过程中是永远看不见的——法律、香肠和软件。&lt;/p&gt;
    
    </summary>
    
      <category term="软件开发" scheme="https://www.keymou.wang/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="软件开发" scheme="https://www.keymou.wang/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>アンナチュラル</title>
    <link href="https://www.keymou.wang/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB.html"/>
    <id>https://www.keymou.wang/アンナチュラル.html</id>
    <published>2018-12-16T02:20:38.000Z</published>
    <updated>2018-12-22T02:25:44.262Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>又是一个周末啦，安利一部日剧《アンナチュラル》非自然死亡  </p><a id="more"></a>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=560738533&auto=1&height=66"></iframe>  <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>三澄美琴（石原里美 饰）是在民间法医组织“UDI”工作的女法医，该组织专门接收由于非正常原因导致死亡的遗体，对其进行解剖以求找到案件的真相。和美琴一起工作的，还有法医中堂系（井浦新 饰）、记录员九部六郎（洼田正孝 饰）和检查技师东海林夕子（市川实日子 饰）等人。 中堂系虽然拥有着丰富的临床经验，个性却乖僻古怪，对正义和法律理解不同的美琴和中堂之间，常常产生无法调和的矛盾。其实，中堂有一个无人知晓的秘密，他的女友在一场“意外”中不幸丧生，可种种蛛丝马迹向中堂揭示了，是一名连环杀人犯取走了女友的性命。中堂不畏人言坚定的留在UDI，正是为了找到杀死女友的凶手。  </p><p>剧情我就不剧透了，优酷、芒果有资源。  </p><p><a href="https://list.youku.com/show/id_zefbfbd3e4cefbfbd03ef.html?spm=a2h0j.11185381.bpmodule-playpage-lefttitle.5~5~H1~8~A" target="_blank" rel="noopener">优酷</a> | <a href="https://www.mgtv.com/h/321935.html?fpa=se" target="_blank" rel="noopener">芒果TV</a>  </p><h4 id="经典台词"><a href="#经典台词" class="headerlink" title="经典台词"></a>经典台词</h4><font face="黑体" color="#FFB6C1"><center>伴侣就要找那种睡相让你觉得很喜欢的人</center></font><br><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj5cjpcj21hc0swhdt.jpg" alt="01"><br><br><font face="黑体" color="#FFB6C1"><center>男女关系中是不会只有一方有错的</center></font><br><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj5zpj5j21gn0v00wv.jpg" alt="02"><br><br><font face="黑体" color="#FFB6C1"><center>有工夫绝望的话 还不如吃点好吃的去睡觉呢</center></font><br><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj66bkjj21hc0u07wh.jpg" alt="03"><br><br><font face="黑体" color="#FFB6C1"><center>只是把孩子当作自己的所有物，不明白孩子跟自己是互相独立的个体</center></font><br><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7ujvswm6j21hc0w3n2f.jpg" alt="04"><br><br><font face="黑体" color="#FFB6C1"><center>对女性的歧视</center></font><br><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj6dikfj21gw0uqq90.jpg" alt="05"><br><br><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj6gr3bj21hc0v242y.jpg" alt="06"><br><br><font face="黑体" color="#FFB6C1"><center>人这种生物 不管是谁<br>切开来剥皮后都只是一团肉而已<br>死了就明白了</center></font>  <p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj6n1srj21h80z9jxk.jpg" alt="07">  </p><font face="黑体" color="#CD5C5C"><center>特别认同中堂这段话，人生不就是这样嘛</center></font>  <p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7ujueenxj21hc0u0427.jpg" alt="08">  </p><font face="黑体" color="#FFB6C1"><center>为了活下去</center></font>  <p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7ujvpv2qj21hc0w4ae0.jpg" alt="09"><br> <font face="黑体" color="#FF00FF"><center>梦想什么的<br>也没必要说得那么夸张<br>有个目标就行<br></center></font>  </p><p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj6rq57j21gi0tyjzr.jpg" alt="10">  </p><p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uj7ffjgj21hc0sw1kz.jpg" alt="11">  </p><font face="黑体" color="#FFB6C1"><center>每个人都是罪人 为了赎罪而工作</center></font>  <p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7ujwwgyjj21hc0y7wjv.jpg" alt="12">  </p><font face="黑体" color="#FF4500"><center><br>不管女性穿什么样的衣服<br>或者喝得酩酊大醉<br>都不能成为肆意妄为的理由<br>没有得到双方一致同意的性行为就是犯罪<br></center></font>    <p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uk5sx0bj21hc0z9txg.jpg" alt="13">  </p><font face="黑体" color="#FFB6C1"><center>欺凌杀人</center></font>  <p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uk6a6ngj21hc17lb29.jpg" alt="14">  </p><font face="黑体"><center>你就算献出了自己的生命<br>你的痛楚<br>肯定也无法传达给他们<br>你的人生 &nbsp;属于你自己</center></font>  <p><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uk6rz0gj21hc0sw4qq.jpg" alt="15">  </p><p><font face="黑体" color="#008000"><center>看官点个赞再走吧</center></font><br><img src="https://ws1.sinaimg.cn/large/663b8092ly1fy7uk5k7txj21hc0u01ky.jpg" alt="16">  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是一个周末啦，安利一部日剧《アンナチュラル》非自然死亡  &lt;/p&gt;
    
    </summary>
    
      <category term="日剧" scheme="https://www.keymou.wang/categories/%E6%97%A5%E5%89%A7/"/>
    
    
      <category term="石原里美" scheme="https://www.keymou.wang/tags/%E7%9F%B3%E5%8E%9F%E9%87%8C%E7%BE%8E/"/>
    
      <category term="日剧" scheme="https://www.keymou.wang/tags/%E6%97%A5%E5%89%A7/"/>
    
      <category term="Unnatural" scheme="https://www.keymou.wang/tags/Unnatural/"/>
    
  </entry>
  
  <entry>
    <title>python常见知识点</title>
    <link href="https://www.keymou.wang/python%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://www.keymou.wang/python常见知识点.html</id>
    <published>2018-12-14T10:23:08.000Z</published>
    <updated>2018-12-16T03:32:06.270Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在学习python，总结了下python常用的知识点。</p><a id="more"></a><h4 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">def fun(a):</span><br><span class="line">    a = 2</span><br><span class="line">fun(a)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = []</span><br><span class="line">def fun(b):</span><br><span class="line">    b.append(1)</span><br><span class="line">fun(b)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>所有的变量都可以理解是内存中一个对象的“引用”。类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。<br>在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。</p><h4 id="实例方法、类方法、静态方法"><a href="#实例方法、类方法、静态方法" class="headerlink" title="实例方法、类方法、静态方法"></a>实例方法、类方法、静态方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def foo(x):</span><br><span class="line">    print(&quot;executing foo(%s)&quot;%(x))</span><br><span class="line"></span><br><span class="line">class A(object):</span><br><span class="line">    def foo(self,x):</span><br><span class="line">        print(&quot;executing foo(%s,%s)&quot;%(self,x))</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def class_foo(cls,x):</span><br><span class="line">        print(&quot;executing class_foo(%s,%s)&quot;%(cls,x))</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def static_foo(x):</span><br><span class="line">        print(&quot;executing static_foo(%s)&quot;%x)</span><br><span class="line"></span><br><span class="line">a=A()</span><br><span class="line">a.foo(2)</span><br><span class="line">a.class_foo(2)</span><br><span class="line">a.static_foo(2)</span><br></pre></td></tr></table></figure><p>先理解下函数参数里面的<code>self</code>和<code>cls</code>。这个<code>self</code>和<code>cls</code>是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.<br>对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>).<br>类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)</code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.</p><p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p><table><thead><tr><th>\</th><th>实例方法</th><th>类方法</th><th>静态方法</th></tr></thead><tbody><tr><td><code>a = A()</code></td><td><code>a.foo(x)</code></td><td><code>a.class_foo(x)</code></td><td><code>a.static_foo(x)</code></td></tr><tr><td><code>A</code></td><td>不可用</td><td><code>A.class_foo(x)</code></td><td><code>A.static_foo(x)</code></td></tr></tbody></table><h4 id="类变量、实例变量"><a href="#类变量、实例变量" class="headerlink" title="类变量、实例变量"></a>类变量、实例变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    name=&quot;aaa&quot;</span><br><span class="line"> </span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=&quot;bbb&quot;</span><br><span class="line">print(p1.name)  # bbb</span><br><span class="line">print(p2.name)  # aaa</span><br><span class="line">print(Person.name)  # aaa</span><br></pre></td></tr></table></figure><p>类变量就是供类使用的变量,实例变量就是供实例使用的。</p><h4 id="Python自省"><a href="#Python自省" class="headerlink" title="Python自省"></a>Python自省</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">b = &apos;Hello&apos;</span><br><span class="line">print(type(a), type(b))</span><br></pre></td></tr></table></figure><ul><li>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型。<br>比如type()、dir()、getattr()、hasattr()、isinstance()</li></ul><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">multiples = [i for i in range(30) if i % 3 is 0]</span><br><span class="line">print(multiples)</span><br><span class="line"></span><br><span class="line">mcase = &#123;&apos;a&apos;: 10, &apos;b&apos;: 34, &apos;A&apos;: 7, &apos;Z&apos;: 3&#125;</span><br><span class="line"></span><br><span class="line">mcase_frequency = &#123;</span><br><span class="line">    k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0)</span><br><span class="line">    for k in mcase.keys()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(mcase_frequency)</span><br><span class="line"># mcase_frequency == &#123;&apos;a&apos;: 17, &apos;z&apos;: 3, &apos;b&apos;: 34&#125;</span><br></pre></td></tr></table></figure><ul><li>列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。规范:<code>variable = [out_exp for out_exp in input_list if out_exp == 2]</code></li><li>字典推导式，上述例子把同一个字母但不同大小写的值合并起来。<br>可以快速对换一个字典的键和值：<br><code>{v: k for k, v in dict.items()}</code></li></ul><h4 id="单下划线和双下划线"><a href="#单下划线和双下划线" class="headerlink" title="单下划线和双下划线"></a>单下划线和双下划线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyClass():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__superprivate = &apos;Hello&apos;</span><br><span class="line">        self._semiprivate = &apos;, world&apos;</span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line">print(mc._semiprivate)</span><br><span class="line">print(mc.__dict__)</span><br><span class="line"># print(mc.__superprivate)</span><br><span class="line"># AttributeError: &apos;MyClass&apos; object has no attribute &apos;__superprivate&apos;</span><br></pre></td></tr></table></figure><ul><li><code>__foo__</code>：一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突.</li><li><code>_foo</code>：一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.</li><li><code>__foo</code>：这个有真正的意义:解析器用_classname__foo来代替这个名字,以区别和其他类相同的命名.</li></ul><h4 id="字符串格式化：-和-format的区别"><a href="#字符串格式化：-和-format的区别" class="headerlink" title="字符串格式化：%和.format的区别"></a>字符串格式化：%和.format的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = &apos;Joe&apos;</span><br><span class="line">print(&apos;Name is %s&apos; %name)</span><br><span class="line">print(&apos;Name is &#123;&#125;&apos;.format(name))</span><br><span class="line">name = (1, 2, 3)</span><br><span class="line"># print(&apos;Name is %s&apos; %name)  # TypeError: not all arguments converted during string formatting</span><br><span class="line">print(&apos;Name is &#123;&#125;&apos;.format(name))</span><br><span class="line">print(&apos;Name is %s&apos; %(name,))</span><br></pre></td></tr></table></figure><p><code>format</code>简洁，<code>%</code>无法同时传递一个变量和元组</p><h4 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mylist = [1, 2, 3]</span><br><span class="line">for i in mylist:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"># mylist is an iterable</span><br><span class="line"># These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.</span><br><span class="line"></span><br><span class="line"># yield is a keyword that is used like return, except the function will return a generator.</span><br><span class="line">def createGenerator():</span><br><span class="line">    mylist = range(3)</span><br><span class="line">    for i in mylist:</span><br><span class="line">        yield i*i</span><br><span class="line"></span><br><span class="line"># create a generator</span><br><span class="line">mygenerator = createGenerator()</span><br><span class="line">print(mygenerator)</span><br><span class="line">for i in mygenerator:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">print(&apos;****&apos;)</span><br><span class="line"># To master yield, you must understand that when you call the function, the code you have written in the function body does not run.</span><br><span class="line">for j in mygenerator:</span><br><span class="line">    print(j)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Generators are iterators, a kind of iterable you can only iterate over once. Generators do not store all the values in memory, they generate the values on the fly.</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h4 id="args-and-kwargs”"><a href="#args-and-kwargs”" class="headerlink" title="*args and **kwargs”"></a>*args and **kwargs”</h4><p>不确定你的函数里将要传递多少参数时你可以用<code>*args</code>。例如，它可以传递任意数量的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def print_everything(*args):</span><br><span class="line">    for count, thing in enumerate(args):</span><br><span class="line">        print(&apos;&#123;0&#125;. &#123;1&#125;&apos;.format(count, thing))</span><br><span class="line"></span><br><span class="line">print_everything(&apos;apple&apos;, &apos;banana&apos;, &apos;cabbage&apos;)</span><br></pre></td></tr></table></figure></p><p><code>**kwargs</code>允许你使用没有事先定义的参数名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def table_things(**kwargs):</span><br><span class="line">    for name, value in kwargs.items():</span><br><span class="line">        print(&apos;&#123;0&#125;=&#123;1&#125;&apos;.format(name, value))</span><br><span class="line"></span><br><span class="line">table_things(apple = &apos;fruit&apos;, cabbage = &apos;vegetable&apos;)</span><br></pre></td></tr></table></figure></p><p>也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给<code>*args</code>和<code>**kwargs</code>。命名参数在列表的最前端，<code>*args</code>和<code>**kwargs</code>可以同时在函数的定义中，但是<code>*args</code>必须在<code>**kwargs</code>前面.</p><h4 id="面向切面编程AOP和装饰器"><a href="#面向切面编程AOP和装饰器" class="headerlink" title="面向切面编程AOP和装饰器"></a>面向切面编程AOP和装饰器</h4><ul><li>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。</li><li><p>装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。<br><strong>概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def makebold(fn):</span><br><span class="line">   def wrapped():</span><br><span class="line">       return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;/b&gt;&quot;</span><br><span class="line">   return wrapped</span><br><span class="line"></span><br><span class="line">def makeitalic(fn):</span><br><span class="line">   def wrapped():</span><br><span class="line">       return &quot;&lt;i&gt;&quot; + fn() + &quot;&lt;/i&gt;&quot;</span><br><span class="line">   return wrapped</span><br></pre></td></tr></table></figure></li><li><p>装饰器的作用就是为已经存在的对象添加额外的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@makebold</span><br><span class="line">@makeitalic</span><br><span class="line">def hello():</span><br><span class="line">    return &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">print(hello())</span><br></pre></td></tr></table></figure></li></ul><h4 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h4><p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为<em>鸭子</em>。<br>并不关心对象是什么类型，到底是不是鸭子，只关心行为。<br>在python中，有很多file-like的东西，比如<code>StringIO</code>,<code>GzipFile</code>,<code>socket</code>。它们有很多相同的方法，我们把它们当作文件使用。</p><h4 id="Python中函数重载"><a href="#Python中函数重载" class="headerlink" title="Python中函数重载"></a>Python中函数重载</h4><ul><li>函数重载主要是为了解决两个问题:可变参数类型、可变参数个数。</li><li>一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载。<br>情况1：函数功能相同，但是参数类型不同，根本不需要处理，因为python可以接受任何类型的参数<br>情况2：函数功能相同，但参数个数不同，答案就是缺省参数。<br><strong>python 自然就不需要函数重载。</strong></li></ul><h4 id="new和init的区别"><a href="#new和init的区别" class="headerlink" title="new和init的区别"></a><strong>new</strong>和<strong>init</strong>的区别</h4><ul><li><code>__new__</code>是一个静态方法,而<code>__init__</code>是一个实例方法.</li><li><code>__new__</code>方法会返回一个创建的实例,而<code>__init__</code>什么都不返回.</li><li>只有在<code>__new__</code>返回一个<code>cls</code>的实例时后面的<code>__init__</code>才能被调用.</li><li>当创建一个新实例时调用<code>__new__</code>,初始化一个实例时用<code>__init__</code>.</li></ul><p>ps: <strong>metaclass</strong>是创建类时起作用.所以我们可以分别使用<strong>metaclass</strong>,<strong>new</strong>和<strong>init</strong>来分别在类创建,实例创建和实例初始化的时候做一些小手脚.</p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><h5 id="使用new方法"><a href="#使用new方法" class="headerlink" title="使用new方法"></a>使用<strong>new</strong>方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    def __new__(cls, *args, **kw):</span><br><span class="line">        if not hasattr(cls, &apos;_instance&apos;):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        return cls._instance</span><br><span class="line"> </span><br><span class="line">class MyClass(Singleton):</span><br><span class="line">    a = 1</span><br></pre></td></tr></table></figure><h5 id="共享属性-创建实例时把所有实例的-dict-指向同一个字典-这样它们具有相同的属性和方法"><a href="#共享属性-创建实例时把所有实例的-dict-指向同一个字典-这样它们具有相同的属性和方法" class="headerlink" title="共享属性 创建实例时把所有实例的__dict__指向同一个字典,这样它们具有相同的属性和方法."></a>共享属性 创建实例时把所有实例的<code>__dict__</code>指向同一个字典,这样它们具有相同的属性和方法.</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Borg(object):</span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    def __new__(cls, *args, **kw):</span><br><span class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        return ob</span><br><span class="line"> </span><br><span class="line">class MyClass2(Borg):</span><br><span class="line">    a = 1</span><br></pre></td></tr></table></figure><h5 id="装饰器版本"><a href="#装饰器版本" class="headerlink" title="装饰器版本"></a>装饰器版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def singleton(cls, *args, **kw):</span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    def getinstance():</span><br><span class="line">        if cls not in instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        return instances[cls]</span><br><span class="line">    return getinstance</span><br><span class="line"> </span><br><span class="line">@singleton</span><br><span class="line">class MyClass:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h5 id="import方法"><a href="#import方法" class="headerlink" title="import方法"></a>import方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mysingleton.py</span><br><span class="line">class My_Singleton(object):</span><br><span class="line">    def foo(self):</span><br><span class="line">        pass</span><br><span class="line"> </span><br><span class="line">my_singleton = My_Singleton()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># to use</span><br><span class="line"># from mysingleton import my_singleton</span><br><span class="line"># my_singleton.foo()</span><br></pre></td></tr></table></figure><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul><li>一个变量的作用域总是由在代码中被赋值的地方所决定的。</li><li>当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：</li><li>本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）</li></ul><h4 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h4><p>闭包(closure)是函数式编程的重要的语法结构<br>创建一个闭包必须满足以下几点:</p><ul><li>必须有一个内嵌函数</li><li>内嵌函数必须引用外部函数中的变量</li><li>外部函数的返回值必须是内嵌函数</li></ul><h4 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h4><p>lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map( lambda x: x*x, [y for y in range(10)] )</span><br></pre></td></tr></table></figure></p><h4 id="Python里的拷贝"><a href="#Python里的拷贝" class="headerlink" title="Python里的拷贝"></a>Python里的拷贝</h4><ul><li>copy浅拷贝，没有拷贝子对象，所以原始数据改变，子对象会改变</li><li>深拷贝，包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">a = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]]  #原始对象</span><br><span class="line"> </span><br><span class="line">b = a  #赋值，传对象的引用</span><br><span class="line">c = copy.copy(a)  #对象拷贝，浅拷贝</span><br><span class="line">d = copy.deepcopy(a)  #对象拷贝，深拷贝</span><br><span class="line"> </span><br><span class="line">a.append(5)  #修改对象a</span><br><span class="line">a[4].append(&apos;c&apos;)  #修改对象a中的[&apos;a&apos;, &apos;b&apos;]数组对象</span><br><span class="line"> </span><br><span class="line">print(&apos;a = &apos;, a)</span><br><span class="line">print(&apos;b = &apos;, b)</span><br><span class="line">print(&apos;c = &apos;, c)</span><br><span class="line">print(&apos;d = &apos;, d)</span><br><span class="line"></span><br><span class="line"># 输出结果：</span><br><span class="line"># a =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]</span><br><span class="line"># b =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]</span><br><span class="line"># c =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]</span><br><span class="line"># d =  [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]]</span><br></pre></td></tr></table></figure></li></ul><h4 id="Python垃圾回收机制"><a href="#Python垃圾回收机制" class="headerlink" title="Python垃圾回收机制"></a>Python垃圾回收机制</h4><p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。<br>在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p><ol><li>引用计数<br>PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。</li><li>标记-清除机制<br>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</li><li>分代技术<br>整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</li></ol><h4 id="Python的is"><a href="#Python的is" class="headerlink" title="Python的is"></a>Python的is</h4><p><code>is</code>是对比地址，<code>==</code>是对比值</p><h4 id="read，readline和readlines"><a href="#read，readline和readlines" class="headerlink" title="read，readline和readlines"></a>read，readline和readlines</h4><ul><li><code>read</code> 读取整个文件</li><li><code>readline</code> 读取下一行,使用生成器方法</li><li><code>readlines</code> 读取整个文件到一个迭代器以供我们遍历</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习python，总结了下python常用的知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.keymou.wang/categories/python/"/>
    
    
      <category term="python" scheme="https://www.keymou.wang/tags/python/"/>
    
  </entry>
  
</feed>
