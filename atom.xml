<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Үміт</title>
  
  <subtitle>心有猛虎，細嗅薔薇</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.keymou.wang/"/>
  <updated>2019-05-12T09:37:48.492Z</updated>
  <id>https://www.keymou.wang/</id>
  
  <author>
    <name>keymou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RIP路由协议</title>
    <link href="https://www.keymou.wang/RIP%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE.html"/>
    <id>https://www.keymou.wang/RIP路由协议.html</id>
    <published>2019-05-02T03:20:34.000Z</published>
    <updated>2019-05-12T09:37:48.492Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​        由于换了份工作，因工作需要的关系，最近开始学习 IP路由技术，总结下个人对 RIP路由协议的理解吧~</p><a id="more"></a><h3 id="RIP-简介"><a href="#RIP-简介" class="headerlink" title="RIP 简介"></a>RIP 简介</h3><p>RIP 是 Routing Information Protocol（路由信息协议）的简称，它是一种较为简单的内部网关协议（Interior Gateway Protocol）。</p><p>RIP 是一种基于距离矢量（Distance-Vector）算法的协议，它使用跳数（Hop Count）作为度量来衡量到达目的网络的距离。</p><p><strong>距离</strong>：也称<strong>跳数</strong>，从一路由器到直连的网络的距离定义为1，从一路由器到非直连路由器的距离定义为所经过的路由器数加1。</p><p>RIP 允许一条路径最多包含15个路由器，即“距离”等于16时不可达。</p><p>RIP 是应用层协议，通过 UDP报文进行路由信息的交换，使用的端口号为520。</p><p>RIP 当前存在两个版本：RIPv1 和 RIPv2。</p><blockquote><p> <strong>距离矢量</strong>名称由来是因为路由是以矢量（距离、方向）的方式被通告出去的，其中距离是根据度量定义的，方向是根据下一跳路由器定义的。每台路由器在信息上都是依赖于邻接路由器，而邻接路由器又是从它们的邻接路由器学习路由，依次类推，所以距离矢量路由选择有时又被认为是“<strong>依照传闻进行路由选择</strong>”。</p></blockquote><p>RIP 特点：每一个路由器都要不断地和其他路由器交换路由信息。</p><ol><li>仅和相邻直连路由器交换信息；</li><li>路由器交换的信息是当前本路由器所知道的所有信息，即当前的路由表；</li><li>按固定时间间隔交换路由信息。</li></ol><h3 id="RIP-工作原理"><a href="#RIP-工作原理" class="headerlink" title="RIP 工作原理"></a>RIP 工作原理</h3><p>RIP 协议是基于D-V 算法实现，RIP 规定，缺省情况下，网关每 30秒向外广播一个 RIP 报文，报文信息来自本地路由表。RIP 报文中，其度量值 metric 以跳数计：与目的网络直接相连的网关规定为 1 跳，相隔一个网关则为 2 跳……依次类推。一条路径的度量值即距离为该路径（从源发送方到目的网络）上的网关数。</p><p>为限制收敛时间，防止路由环路，RIP 规定度量值取 0~15 之间的整数，大于或等于 16 的跳数被定义为无穷大，即目的网络或主机不可达。由于这个限制，使得 RIP 不可能在大型网络中得到应用。</p><h4 id="路由数据库"><a href="#路由数据库" class="headerlink" title="路由数据库"></a>路由数据库</h4><p>每个运行RIP的路由器管理一个路由数据库，数据库包含了到所有可达目的地的路由项，路由项包含以下信息：</p><ul><li>Destination/Mask（目的 IP）：主机或网络的地址、掩码</li><li>Nexthop （下一跳地址）：到达目的地址需要经过的相邻路由器的 IP</li><li>Interface（出接口）：本路由器转发报文的出接口</li><li>Cost（度量值）：本路由到达目的地的开销</li><li>Sec（路由时间）</li><li>Tag（路由标记）</li></ul><h4 id="RIP-运行过程"><a href="#RIP-运行过程" class="headerlink" title="RIP 运行过程"></a>RIP 运行过程</h4><p><img src="https://github.com/keymou/blog_images/raw/master/content/RIP%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/GIF.gif" alt="RIP 运行示例"></p><p><strong>初始状态</strong>：路由器开启 RIP进程，宣告相应接口或网络段，对路由表进行初始化，为每一个和它直接相S连地实体建一个路由条目，并设置目的 IP/Mask （直连网段），Nexthop为 0.0.0.0，metric为 0。设备从相关接口发送和接收 RIP 报文。<img src="https://github.com/keymou/blog_images/raw/master/content/RIP%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/rip%20router.gif" alt="dis rip 1 router"></p><p><strong>构建路由表</strong>：路由器依据收到的 RIP 报文构建自己的路由条目，并给每个路由器初始化更新定时器（缺省值为 30 秒）和老化定时器（缺省值为 180 秒）。</p><p><strong>维护路由表</strong>：路由器每隔 30 秒发送更新报文，同时接收相邻路由器发送的更新报文以维护路由条目。</p><p><strong>老化路由表项</strong>：如果在 180 秒内没有收到关于某条路由器的更新，则该条路由在路由表中的度量值 metric 将会被设置为 16，路由被老化。</p><p><strong>垃圾收集表项</strong>：在180 秒过后，路由器仍没有收到相应路由条目的更新，路由老化，该跳路由条目度量值设为 16， RIP 以度量值为 16 向外发送这条路由的更新，同时启动缺省值为 120 秒的垃圾收集定时器。</p><p><strong>删除路由表项</strong>：120 秒之后，路由器仍然没有收到相应路由条目的更新，则路由器将该路由条目删除。</p><h4 id="RIP-路由表的形成"><a href="#RIP-路由表的形成" class="headerlink" title="RIP 路由表的形成"></a>RIP 路由表的形成</h4><p>RIP 启动时的初始路由表仅包含本设备的一些直连接口路由。通过相邻设备互相学习路由表项，才能实现各网段路由互通。</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/RIP%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/router%E5%BD%A2%E6%88%90.gif" alt="路由表的形成"></p><p>RIP 路由表简化过程如上图所示：</p><ul><li>RIP 协议启动后，RouterA 会向相邻的路由器广播（RIPv2 缺省是组播）一个 Request 报文</li><li>当 RouterB 从接口接收到 RouterA发送的 Request报文后，把自己的 RIP 路由表封装在 Response 报文内，然后向该接口对应的网络广播、</li><li>RouterA 根据 RouterB 发送的 Response 报文，形成自己的路由表</li></ul><h4 id="RIP-更新维护"><a href="#RIP-更新维护" class="headerlink" title="RIP 更新维护"></a>RIP 更新维护</h4><p>RIP 协议在更新和维护路由信息时收到四个定时器控制</p><h5 id="更新定时器-Update-timer"><a href="#更新定时器-Update-timer" class="headerlink" title="更新定时器 Update timer"></a>更新定时器 Update timer</h5><p>定义了发送路由器更新的时间间隔，缺省为 30 秒，当此定时器超时时，立即发送更新报文。</p><h5 id="老化定时器（Age-timer）"><a href="#老化定时器（Age-timer）" class="headerlink" title="老化定时器（Age timer）"></a>老化定时器（Age timer）</h5><p>定义了路由条目的老化时间。如果在老化时间内没有收到邻接路由器发来关于某条路由器的更新报文，则该条路由在路由表中的度量值将会被设置为 16，认为该路由不可达。</p><ul><li>在路由创建被创建时初始化</li><li>每次收到这条路由对应的路由更新时，重新初始化</li><li>如果定期器在缺省180s内没有更新，路由超时</li></ul><h5 id="垃圾收集定时器（Garbage-collect-timer）"><a href="#垃圾收集定时器（Garbage-collect-timer）" class="headerlink" title="垃圾收集定时器（Garbage-collect timer）"></a>垃圾收集定时器（Garbage-collect timer）</h5><p>定义了一条路由器从度量值变为16开始，直到它从路由表里被删除所经过的时间，用于“垃圾回收”。若在垃圾收集时间内不可达路由没有收到来自同一邻居的更新，则该路由将被从 RIP 路由表中彻底删除。</p><ul><li>路由的权重设置为16，RIP以度量值为16发送这条路由的更新</li><li>缺省120s后，仍没有得到更新，删除该路由</li></ul><h5 id="抑制定时器（Suppress-timer）"><a href="#抑制定时器（Suppress-timer）" class="headerlink" title="抑制定时器（Suppress timer）"></a>抑制定时器（Suppress timer）</h5><p>定义了RIP路由处于抑制状态的时长。当一条路由的度量值变为16时，该路由将进入抑制状态。在抑制状态，只有来自同一邻居并且度量值小于16的路由更新才会被路由器接收，取代不可达路由。缺省为120s。</p><h4 id="RIP-防止路由环路的机制"><a href="#RIP-防止路由环路的机制" class="headerlink" title="RIP 防止路由环路的机制"></a>RIP 防止路由环路的机制</h4><h5 id="路由环路的产生原因"><a href="#路由环路的产生原因" class="headerlink" title="路由环路的产生原因"></a>路由环路的产生原因</h5><p><img src="https://github.com/keymou/blog_images/raw/master/content/RIP路由协议/环路.PNG" alt=""></p><p>正常 192.168.0.0/24 网络被 RA 通告到 RB。当网络出现问题不能达到的时候，路由RA 等更新周期到来把192.168.0.0/24 路由信息不可达信息通告给 RB。但是 RB 在 RA 更新周期前通告给了 RA，让 RA 误以为通过 RB 的那边能达到 192.168.0.0/24 网络，结果就是造成路由环路。</p><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><h6 id="1-计数到无穷（Counting-to-infinity）"><a href="#1-计数到无穷（Counting-to-infinity）" class="headerlink" title="1. 计数到无穷（Counting to infinity）"></a>1. 计数到无穷（Counting to infinity）</h6><p>将度量值等于16的路由定义为不可达（infinity）。在路由环路发生时，某条路由的度量值将会增加到16，该路由被认为不可达，避免路由环路的产生。</p><h6 id="2-触发更新（Triggered-Updates）"><a href="#2-触发更新（Triggered-Updates）" class="headerlink" title="2. 触发更新（Triggered Updates）"></a>2. 触发更新（Triggered Updates）</h6><p>RIP 通过触发更新来避免在多个路由器之间形成路由环路的可能，而且可以加快网络的收敛速度。一旦某条路由的度量值发生了变化，就立即向邻居路由器发布更新报文，而不是等到更新周期的到来。</p><h6 id="3-水平分割（Split-Horizon）"><a href="#3-水平分割（Split-Horizon）" class="headerlink" title="3. 水平分割（Split Horizon）"></a>3. 水平分割（Split Horizon）</h6><p>RIP 从某个接口学到的路由信息不会重新发回该接口的邻居路由器。这样不但减少带宽消耗，还可以防止路由环路。</p><p>水平分割在不同网络中实现有所区别，分为按照接口和按照邻居进行水平分割。广播网、P2P 和 P2MP 网络中是按照接口进行水平分割的，如下图所示：</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/RIP路由协议/水平分割_1.png" alt=""></p><p>RouterA 会向 RouterB 发送到网络 10.0.0.0/8 的路由信息，如果没有配置水平分割，RouterB 会将从 RouterA 学习到的这条路由再发送回给 RouterA。这样，RouterA 可以学习到两条到达 10.0.0.0/8 网络的路由：跳数为 0 的直连路由；下一跳指向 RouterB，且跳数为 2 的路由。</p><p>但是在 RouterA 的 RIP 路由表中只有直连路由才是活跃的。当 RouterA 到网络 10.0.0.0 的路由变成不可达，并且 RouterB 还没有收到路由不可达的信息时，RouterB 会继续向 RouterA 发送 10.0.0.0/8 可达的路由信息。即，RouterA 会接受到错误的路由信息，认为可以通过 RouterB 到达 10.0.0.0/8 网络；而 RouterB 仍旧认为可以通过 RouterA 到达 10.0.0.0/8 网络，从而形成路由环路。配置水平分割后，RouterB 将不会再把到网络 10.0.0.0/8 的路由发回给 RouterA，由此避免了路由环路的产生。</p><p>对于 NBMA（Non-Broadcast Multiple Access）网络，由于一个接口上连接多个邻居，所以是按照邻居进行水平分割的。路由就会按照单播方式发送，同一接口上收到的路由可以按邻居进行区分。从某一接口的对端邻居处学习到路由，不会再通过该接口发送回去。</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/RIP路由协议/水平分割_2.png" alt=""></p><p>在 NBMA 网络配置了水平分割之后，RouterA 会将从 RouterB 学习到的 102.16.0.0/16 路由发送给 RouterC，但是不会再发送回给 RouterB。</p><h6 id="4-毒性逆转（Poison-Reverse）"><a href="#4-毒性逆转（Poison-Reverse）" class="headerlink" title="4. 毒性逆转（Poison Reverse）"></a>4. 毒性逆转（Poison Reverse）</h6><p>RIP 从某个接口学到路由后，将该路由的度量值设为 16（不可达），并从原接口发送回邻居路由器。利用这种方式，可以清楚对方路由表中的无用信息。</p><p>水平分割和毒性逆转都是为了防止 RIP 中的路由环路而设计的，但是水平分割是不将收到路由条目再按 “原路返回” 来避免环路，而毒性逆转遵循 “坏消息比没消息好” 的原则，即将路由条目按“原路返回”，但是该路由条目被标记为不可达（度量值为 16）。</p><h4 id="RIP-消息"><a href="#RIP-消息" class="headerlink" title="RIP 消息"></a>RIP 消息</h4><p>RIP 报文由头部（Header）和多个路由条目（Route Entries）部分组成。每个路由条目包含地址族标识、路由可达的 IP 地址和路由跳数。</p><p>RIP 报文的头部占用 4 个字节，每个路由条目占用 20 个字节。</p><h5 id="RIP-报文接收处理"><a href="#RIP-报文接收处理" class="headerlink" title="RIP 报文接收处理"></a>RIP 报文接收处理</h5><p>相邻的实体收到广播时，就对广播的数据报进行检查。因为广播的内容可能引起路由表的更新，所以这种检查是细致的。当报文传至 IP 层时：</p><p>检查报文端口：是否来自端口 520 的 UDP 数据报，若不是则忽略，因为路由器不转发受限制广播。</p><p>检查 RIP 报文的 Version：</p><ol><li>取值为 0，忽略该报文；</li><li>取值为 1，检查 Must be zero 的字段值：若“Must be zero”字段值不为 0，则忽略该报文；</li><li>取值大于 1，Must be zero 字段值不做检查。</li></ol><p>检查 RIP 报文中 Command：</p><ol><li><p>取值为 1-Request 报文：</p><p>根据报文内的网段信息，依次查找本地路由表。</p><p>(a) 若发现匹配，将本地路由表的权重填写到返回结果中；(b) 若没有发现匹配，填写16，并将 Command 字段值设置为 2，将报文发送回。</p><p>特殊情况：若 request 报文的 IP 类型是0，并且请求的路由只有一条，权重为16，需要发送本地所有的路由表。</p></li><li><p>取值为 2- Response 报文：</p><p>源地址必须是路由器的邻居地址，若不是来自直接邻居，则报文被忽略；过滤从自己发出的报文。</p><p>更新路由的度量值：Metric = MIN（metric + cost, 16）；</p><p>查看本地路由表中是否已经存在该路由：</p><ul><li><p>不存在，检查则本地路由表添加该条路由：①设置目的地址与度量值；②从更新数据包中的源地址字段读取通告路由器的地址，设置为下一跳；③初始化定时器；④发起触发更新；</p><p>若收到路由的 metric 为16，则不用添加。</p></li><li><p>存在，只有在新的路由器拥有更小的跳数时才能替换原来存在的路由条目。</p><p>路由更新通告的跳数大于路由表已记录的跳数，并且更新来自已记录条目的下一跳路由器，则该路由进入一个指定的抑制时间段内被标记为不可到达，若在抑制时间（缺省值 120 秒）超时后，同一台路由器仍然通告这个有较大跳数的路由，则路由则接收该路由新的度量值。</p></li></ul></li></ol><h5 id="RIPv1-报文"><a href="#RIPv1-报文" class="headerlink" title="RIPv1 报文"></a>RIPv1 报文</h5><p>一个 RIPv1 Response 报文中，最多可以有 25 个路由条目，加上 8 个字节的 UDP 头部，RIP 数据报的大小（不含 IP 包的头部）最大可达 512 个字节。</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/RIP路由协议/RIPv1.png" alt="RIPv1"></p><ul><li>Command：取值 1 或 2，1 表示该消息是请求消息；2 表示是响应消息。</li><li>Version：对于 RIPv1，该字段值为 1；对于RIPv2，设置为2。RIPv2可处理有效的RIPv1。</li><li>Must be zero：字段值必须为零。</li><li>Address Family Identifier：对于 IP 该项设置为 2。例外情况，该消息是路由器整个路由表的请求，该项设置为 0。</li><li>IP Address：路由的目的地址，可以是主网络地址、子网地址或主机路由地址。</li><li>Metric：跳数，取值在0~16之间</li></ul><h6 id="RIPv1-特点"><a href="#RIPv1-特点" class="headerlink" title="RIPv1 特点"></a>RIPv1 特点</h6><ol><li>RIPv1 是<strong>有类别路由</strong></li><li>只支持以<strong>广播方式</strong>发布，广播地址 255.255.255.255</li><li>基于 UDP，端口号 520</li><li>RIP 报文无法携带掩码信息，只能识别 A、B、C 类的自然网段的路由，因此 RIPv1 不支持不连续子网，也无法支持路由聚合</li><li>不支持验证</li></ol><p><strong>有类别路由协议</strong>的一个基本特征是：在通告目的地址时不能随之一起通告它的地址掩码。因此，有类别路由选择协议首先必须匹配一个与该目的地址对应于A类、B类或C类的主网络号。对于每一个通过这台路由器的数据包：</p><ul><li>如果目的地址是一个和路由器直接相连的主网络的成员，那么该网络的路由器接口上配置的子网掩码将被用来确认目的地址的子网。</li><li>如果目的地址不是一个和路由器直接相连的主网络的成员，那么路由器将尝试匹配该目的地址对应于A类、B类或C类的主网络号。</li></ul><h6 id="RIPv1-发送"><a href="#RIPv1-发送" class="headerlink" title="RIPv1 发送"></a>RIPv1 发送</h6><p>注意发送时没有子网掩码。</p><p>将要发送的前缀路由和出接口网段匹配：</p><ol><li>如果不在同一主网，此为主网边界，将前缀自动汇总为有类网段发送前缀到出接口。</li><li>如果在同一主网，检查发送的前缀是否为 32 位：<ol><li>如果是，发送 32 位前缀到出接口。</li><li>如果不是，检查前缀和出口掩码是否相同： <ol><li>如果不同，抑制发送或者汇聚为主网络号。</li><li>如果相同，没有边界，发送正确的前缀到出接口。</li></ol></li></ol></li></ol><h6 id="RIPv1-接收"><a href="#RIPv1-接收" class="headerlink" title="RIPv1 接收"></a>RIPv1 接收</h6><p>收到一个前缀后，如果发现是主网络号，直接放入路由表，掩码是 8/16/24.</p><p>如果不是主网络号，检查是否在同一主网：</p><ol><li>如果不在，生成有类路由，掩码按有类路由计算。</li><li>如果在同一主网，用接口掩码去掩，然后检查该前缀是网络地址还是主机地址：<ol><li>如果是网络地址，生成路由，掩码等于自己的接口掩码，放入路由表。</li><li>如果不是网络地址，就默认是主机地址，生成 32 位路由，放入路由表。</li></ol></li></ol><h5 id="RIPv2-报文"><a href="#RIPv2-报文" class="headerlink" title="RIPv2 报文"></a>RIPv2 报文</h5><h6 id="不携带认证的-RIPv2"><a href="#不携带认证的-RIPv2" class="headerlink" title="不携带认证的 RIPv2"></a>不携带认证的 RIPv2</h6><p><img src="https://github.com/keymou/blog_images/raw/master/content/RIP路由协议/RIPv2.png" alt=""></p><ul><li>Command：取值 1 或 2，1 表示该消息是请求消息；2 表示是响应消息。</li><li>Version：对于 RIPv2，设置为 2。RIPv2可处理有效的RIPv1。</li><li>Reserverd：保留字段。</li><li>Address Family Identifier：对于 IP 该项设置为 2。例外情况，该消息是路由器整个路由表的请求，该项设置为 0。</li><li>Route Tag：提供这个字段用来标记外来路由或重新分配到 RIPv2 协议中的路由。默认情况是使用这个16位的字段来携带从外部路由选择协议注入到 RIP 中的路由的自主系统号。</li><li>IP Address：路由的目的地址，可以是主网络地址、子网地址或主机路由地址。</li><li>Subnet Mask：子网地址，32位掩码，用来标识 IPv4 地址的网络和子网部分。对于 RIPv1，该字段设置为全0。</li><li>Nexthop：若存在的话，它标识一个比通告路由器的地址更好的下一跳地址。若这个字段设置为全 0（0.0.0.0），说明通告路由器的地址是最优的下一跳地址。对于 RIPv1，该字段设置为全 0。</li><li>Metric：跳数，取值在0~16之间</li></ul><h6 id="携带认证的-RIPv2"><a href="#携带认证的-RIPv2" class="headerlink" title="携带认证的 RIPv2"></a>携带认证的 RIPv2</h6><p><img src="https://github.com/keymou/blog_images/raw/master/content/RIP路由协议/RIPv2_认证.png" alt=""></p><p>RIPv2 在有认证的情况下最多携带 24 条路由。认证报文格式如上，其中 Authentication Type 为认证类型，RIPv2 支持简单认证和 MD5 认证两种方式，口令长度不足的补 0。</p><h6 id="RIPv2-的增强特性"><a href="#RIPv2-的增强特性" class="headerlink" title="RIPv2 的增强特性"></a>RIPv2 的增强特性</h6><ol><li><strong>无类别路由协议</strong></li><li><strong>组播</strong>更新，组播地址 224.0.0.9</li><li>基于 UDP，端口号 520</li><li>支持外部 Tag，用于过滤和做策略</li><li>支持路由聚合和 CIDR（无类域间路由）</li><li>支持指定下一跳</li><li>支持认证</li></ol><h6 id="RIPv2-接收和发送"><a href="#RIPv2-接收和发送" class="headerlink" title="RIPv2 接收和发送"></a>RIPv2 接收和发送</h6><p>在开启自动汇总的情况下（默认），不同主网，汇总发。同一主网，带原有的掩码发。不开自动汇总的情况下，不管是不是同一主网，一律发原有的掩码。</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/RIP路由协议/RIPv2_2.PNG" alt=""></p><h6 id="RIPv2-路由聚合"><a href="#RIPv2-路由聚合" class="headerlink" title="RIPv2 路由聚合"></a>RIPv2 路由聚合</h6><p>路由聚合的原理是，同一个自然网段内的不同子网的路由在向外（其它网段）发送时聚合成一个网段的路由发送。</p><ul><li>RIPv2 支持路由聚合，因为 RIPv2 报文携带掩码位，所以支持子网划分。在 RIPv2 中进行路由聚合可提高大型网络的可扩展性和效率，缩减路由表。</li><li>基于 RIPv2 进程的有类聚合即实现自动聚合。</li><li>基于接口的聚合即实现手动聚合。</li><li>如果被聚合路由携带了 Tag，那么路由聚合发生之后，Tag 信息将被清除。</li></ul><p>路由聚合有两种方式：</p><ul><li><p>基于 RIP 进程的有类聚合：</p><p>聚合后的路由使用自然掩码的路由形式发布。比如，对于 10.1.1.0/24（metric=2）和 10.1.2.0/24（metric=3）这两条路由，会聚合成自然网段路由 10.0.0.0/8（metric=2）。RIP–2 聚合是按类聚合的，聚合得到最优的 metric 值。</p></li><li><p>基于接口的聚合：</p><p>用户可以指定聚合地址。比如，对于 10.1.1.0/24（metric=2）和 10.1.2.0/24（metric=3）这两条路由，可以在指定接口上配置聚合路由 10.1.0.0/16（metric=2）来代替原始路由。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​        由于换了份工作，因工作需要的关系，最近开始学习 IP路由技术，总结下个人对 RIP路由协议的理解吧~&lt;/p&gt;
    
    </summary>
    
      <category term="IP路由协议" scheme="https://www.keymou.wang/categories/IP%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="IP路由协议" scheme="https://www.keymou.wang/tags/IP%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="RIP" scheme="https://www.keymou.wang/tags/RIP/"/>
    
  </entry>
  
  <entry>
    <title>Selenium 3 自动化测试实践</title>
    <link href="https://www.keymou.wang/Selenium%203%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5.html"/>
    <id>https://www.keymou.wang/Selenium 3 自动化测试实践.html</id>
    <published>2019-01-15T09:22:40.000Z</published>
    <updated>2019-04-27T03:47:21.336Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>介绍下<em>Web</em> 应用程序界面常用的自动化测试框架 <em>Selenium</em>。</p><a id="more"></a><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a><em>Selenium</em></h3><h4 id="Selenium-是什么"><a href="#Selenium-是什么" class="headerlink" title="Selenium 是什么"></a><em>Selenium</em> 是什么</h4><p><em>Selenium</em> 是用于测试 <em>Web</em> 应用程序用户界面（<em>UI</em>）的自动化测试框架。它是一款用于运行端到端功能测试的超强工具。您可以使用多个编程语言编写测试，并且 <em>Selenium</em>能够在一个或多个浏览器中执行这些测试。</p><p>特点：</p><ul><li>开源，免费；</li><li>多浏览器支持：<em>Firefox、Chrome、IE、Edge、Opera</em>；</li><li>多平台支持：<em>Linux、Windows、MAC</em>；</li><li>多语言支持：<em>Java、Python、Ruby、C#、JavaScript</em>；</li><li><em>API</em> 简单、灵活</li></ul><p>通过 Selenium，可以编写代码让浏览器：</p><ul><li>自动加载网页，获取当前呈现页面的源码；</li><li>模拟点击和其他交互方式，最常用：模拟表单提交(比如模拟登录)；</li><li>截取页面；</li><li>判断网页某些动作是否发生，如页面是否刷新，等等。</li></ul><h4 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h4><h5 id="Selenium-1-0"><a href="#Selenium-1-0" class="headerlink" title="Selenium 1.0"></a><em>Selenium 1.0</em></h5><p><em>2004</em>年，<em>ThoughtWorks</em>公司的 <em>JasonHuggins</em> 和他所在的团队采用 <em>Javascript</em> 编写一种测试工具来验证浏览器页面的行为。这个<em>JavaScript</em> 类库就是 <em>Selenium core</em>，同时也是 <em>seleniumRC</em>、<em>Selenium IDE</em> 的核心组件。</p><p>之后 <em>Paul Hammant</em> 加入团队并指导开发第二种操作模式，后来成为 <em>Selenium Remote Control（RC）</em>。</p><blockquote><p><strong>关于命名</strong></p><p>当时<em>QTP mercury</em>是主流的商业自动化工具，是化学元素汞（俗称水银），而<em>Selenium</em>是开源自动化工具，是化学元素硒，硒可以对抗汞。</p></blockquote><p><img src="https://github.com/keymou/blog_images/raw/master/content/Selenium3%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/1.png" alt="JasonHuggins"></p><p><em>Selenium1.0</em> 框架组成：</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/Selenium3%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/2.png" alt="Selenium1 家谱"></p><p><strong><em>Selenium 1.0 = Selenium IDE + Selenium Grid + SeleniumRC</em></strong></p><ul><li><p><em>Selenium IDE</em>：</p><p><em>Selenium IDE</em> 是嵌入到Firefox浏览器中的一个插件，实现简单的浏览器操作的录制与回放功能；</p><p>官方给出它自身作用的定位：</p><blockquote><p>快速地创建bug重现脚本，在测试人员测试过程中，发现bug之后可以通过IDE将重现的步骤录制下来，以帮助开发人员更容易的重现bug；</p></blockquote><p>可访问<a href="https://docs.seleniumhq.org/download/" target="_blank" rel="noopener">这里</a>下载对应 <strong><em>IDE</em></strong>。由于实践中不涉及用<em>Selenium IDE</em> 生成脚本，这里不多做介绍了。</p></li><li><p><em>Selenium Grid</em>：</p><p><em>Selenium Grid</em> 是一种自动化的测试辅助工具，<em>Grid</em> 通过利用现有的计算机基础设施，能加快<em>Web-App</em> 的功能测试。利用<em>Grid</em> 可以很方便地实现在多台机器上和异构环境中运行测试用例。</p><p><strong>工作原理</strong>：</p><p><em>Selenium Grid</em> 实际它是基于<em>Selenium RC</em> 的，而所谓的分布式结构就是由一个<em>hub</em> 节点和若干个<em>node</em> 代理节点组成。<em>Hub</em> 用来管理各个代理节点的注册信息和状态信息，并且接受远程客户端代码的请求调用，然后把请求的命令转发给代理节点来执行。</p></li><li><p><em>Selenium RC</em>：</p><p><em>Selenium RC</em>（<em>Remote Control</em>）是<em>Selenium</em>家族的核心部分。<em>Selenium RC</em> 支持多种不同语言编写的自动化测试脚本，通过<em>Selenium RC</em>的服务器作为代理服务器去访问应用，从而达到测试的目的。</p><p><em>Selenium RC</em> 分为<em>Client Libraries</em> 和<em>Selenium Server</em>。<em>Client Libraries</em> 库主要用于编写测试脚本，用来控制<em>Selenium Server</em> 的库。<em>Selenium Server</em> 负责控制浏览器行为。</p></li></ul><h5 id="Selenium-2-0"><a href="#Selenium-2-0" class="headerlink" title="Selenium 2.0"></a><em>Selenium 2.0</em></h5><p><em>2006</em>年，<em>Google</em> 的工程师<em>SimonStewart</em> 发起了<em>WebDriver</em> 的项目，因为长期以来<em>Google</em> 一直是<em>Selenium</em> 的重度用户，但却被限制在有限的操作范围内。</p><p><em>Selenium RC</em> 与<em>WebDriver</em> 区别：</p><p><strong><em>Selenium RC</em> 是在浏览器中运行<em>JavaScript</em> 应用，使用浏览器内置的<em>JavaScript</em> 翻译器来翻译和执行<em>selenses</em> 命令（<em>selenses</em> 是<em>Selenium</em> 命令集合）。</strong></p><p><strong><em>WebDriver</em> 是通过原生浏览器支持或浏览器扩展来直接控制浏览器</strong>。</p><p><em>WebDriver</em> 针对各个浏览器而开发，取代了嵌入到被测<em>Web</em> 应用中的<em>JavaScript</em>，与浏览器紧密集成，因此支持创建更高级的测试，避免了<em>JavaScript</em> 安全模型导致的限制。除了来自浏览器厂商的支持之外，<em>WebDriver</em> 还利用操作系统级的调用，模拟用户输入。</p><p><em>Selenium</em> 与<em>WebDriver</em> 原是属于两个不同的项目，<em>WebDriver</em> 的创建者<em>Simon Stewart</em> 早在<em>2009</em>年<em>8</em>月的一份邮件中解释了项目合并的原因。</p><blockquote><p><em>Selenium</em> 与<em>WebDriver</em> 合并原因：为何把两个项目合并？部分原因是<em>WebDriver</em> 解决了<em>Selenium</em> 存在的缺点（例如能够绕过<em>JavaScript</em> 沙箱，我们有出色的<em>API</em> ），部分原因是<em>Selenium</em> 解决了<em>WebDriver</em> 存在的问题（例如支持广泛的浏览器），部分原因是因为<em>Selenium</em> 的主要贡献者和我都觉得合并项目是为用户提供最优先框架的最佳途径。</p></blockquote><p><strong><em>Selenium 2.0 = Selenium 1.0 + WebDriver</em></strong></p><p>需要强调的是，在<em>Selenium 2.0</em> 中主推的是 <em>WebDriver</em>，可以将其看作<em>SeleniumRC</em> 的替代品。因为<em>Selenium</em> 为了保持向下的兼容性，所以在<em>Selenium 2.0</em> 中并没有彻底地抛弃<em>Selenium RC</em>。</p><p><em>Selenium 2</em>具有来自<em>WebDriver</em> 的清晰面向对象 <em>API</em> ，并能以最佳的方式与浏览器进行交互。<em>Selenium 2</em>不使用 <em>JavaScript</em> 沙盒，它支持多种浏览器和多语言绑定。</p><p><em>Selenium 2</em>为下列程序提供驱动程序：</p><ul><li><em>Mozilla Firefox</em></li><li><em>Google Chrome</em></li><li><em>Microsoft Internet Explorer</em></li><li><em>Opera</em></li><li><em>Apple iPhone</em></li><li><em>Android browsers</em></li><li><em>……</em></li></ul><p>借助 <em>Selenium 2</em>，您可使用 <em>Java</em>、<em>C#</em>、<em>Ruby</em>、和 <em>Python</em> 编写测试。<em>Selenium 2</em> 还提供基于 <em>HtmlUnit</em>的无外设驱动，是用于测试 <em>Web</em>应用程序的 <em>Java</em>框架。<em>HtmlUnit</em>运行速度特别快，但它不是一个真正与真实浏览器相关联的驱动。</p><p><strong><em>WebDriver</em></strong> 原理：</p><p><em>WebDriver</em> 是按照<em>Server-Client</em> 的设计模式设计的；</p><p><em>Server</em> 端就是<em>Remote Server</em>，可以是任意的浏览器；当我们的脚本启动浏览器后，该浏览器是<em>Remote Server</em>，职责是等待<em>Client</em> 发送请求并做出响应。</p><p><em>Client</em> 端简单理解是测试代码；脚本的行为是以<em>http</em> 请求的方式发送给测试的浏览器，浏览器接受请求，执行相应操作，并在<em>response</em> 中返回执行状态，返回等信息。</p><p><em>WebDriver</em> 的工作流程：</p><ul><li><em>WebDriver</em> 启动目标浏览器，并绑定到指定端口；启动的浏览器实例将作为<em>WebDriver</em> 的<em>Remote Server</em>；</li><li><em>Client</em> 端通过<em>CommandExcuter</em> 发送<em>HTTPRequest</em> 给<em>Remote Server</em> 的侦听端口；</li><li><em>Remote Server</em> 需要依赖原生的浏览器组件来转化浏览器的native调用；</li></ul><h5 id="Selenium-3-0"><a href="#Selenium-3-0" class="headerlink" title="Selenium 3.0"></a><em>Selenium 3.0</em></h5><p><em>2016</em>年<em>7</em>月，<em>Selenium3.0</em> 发布了第一个<em>Beta</em> 版本。</p><p><strong><em>Selenium 3.0 = Selenium 2.0 + Selenium RC（Remote Control）</em></strong></p><p><em>Selenium 3</em> 核心的安装包中彻底删除了<em>Selenium RC</em> 。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>直接使用 <em>pip</em> 命令安装，命令如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><p>查看安装 <em>selenium</em> 是否成功，显示 <em>selenium</em> 版本信息则安装成功。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip show selenium</span><br></pre></td></tr></table></figure><p><img src="https://github.com/keymou/blog_images/raw/master/content/Selenium3%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/3.png" alt="pip show selenium"></p><p>接下来还需要下载浏览器驱动，<em>Selenium</em> 是不支持浏览器功能的，需要和第三方的浏览器一起搭配使用，支持下述浏览器，你需要把对应的浏览器驱动下载到 Python 目录下：</p><ul><li><a href="https://sites.google.com/a/chromium.org/chromedriver/" target="_blank" rel="noopener">Chrome</a></li><li><a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">Firefox</a></li><li><a href="https://phantomjs.org/" target="_blank" rel="noopener">PhantomJS</a></li><li><a href="https://selenium-release.storage.googleapis.com/index.html" target="_blank" rel="noopener">IE</a></li><li><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/" target="_blank" rel="noopener">Edge</a></li><li><a href="https://github.com/operasoftware/operachromiumdriver/releases" target="_blank" rel="noopener">Opera</a></li><li><a href="https://webkit.org/blog/6900/webdriver-support-in-safari-10/" target="_blank" rel="noopener">Safari</a></li></ul><p>不过得注意一点，浏览器驱动版本支持的浏览器版本，拿 <em>Chrome driver</em> 与 <em>chrome</em>版本对应关系举例：</p><table><thead><tr><th style="text-align:center"><em>Chrome driver 版本</em></th><th style="text-align:center"><em>Chrome 版本</em></th></tr></thead><tbody><tr><td style="text-align:center"><em>v2.45</em></td><td style="text-align:center"><em>v70-72</em></td></tr><tr><td style="text-align:center"><em>v2.44</em></td><td style="text-align:center"><em>v69-71</em></td></tr><tr><td style="text-align:center"><em>v2.43</em></td><td style="text-align:center"><em>v69-71</em></td></tr><tr><td style="text-align:center"><em>v2.42</em></td><td style="text-align:center"><em>v68-70</em></td></tr><tr><td style="text-align:center"><em>v2.41</em></td><td style="text-align:center"><em>v67-69</em></td></tr><tr><td style="text-align:center"><em>v2.40</em></td><td style="text-align:center"><em>v66-68</em></td></tr><tr><td style="text-align:center"><em>v2.39</em></td><td style="text-align:center"><em>v66-68</em></td></tr><tr><td style="text-align:center"><em>v2.38</em></td><td style="text-align:center"><em>v65-67</em></td></tr><tr><td style="text-align:center"><em>v2.37</em></td><td style="text-align:center"><em>v64-66</em></td></tr><tr><td style="text-align:center"><em>v2.36</em></td><td style="text-align:center"><em>v63-65</em></td></tr></tbody></table><p>通过在 Chrome 浏览器地址栏输入以下命令，获取浏览器版本信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://version/</span><br></pre></td></tr></table></figure><p><img src="https://github.com/keymou/blog_images/raw/master/content/Selenium3%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/4.png" alt="chrome version"></p><p>主要是关注版本号：71.0.3578.98 (正式版本)，参考上面选择下载对应 <em>Chrome  v71</em>版本的<em>Chrome driver</em>，选择下载 <em>v2.45</em>，根据操作系统选择对应的浏览器驱动，<em>Windows</em> 平台 <em>chrome driver</em> 没有 <em>64</em>位版本，选择下载 <em>win32</em>版本即可。</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/Selenium3%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/5.png" alt="chromedriver download"></p><p>下载完成后，解压 <em>zip</em>文件，解压后的 <em>chromedriver.exe</em> 拷贝到<em>Python</em> 的 <em>\Scripts</em> 目录下。<em>Mac</em> 的话把解压后的文件拷贝到 <em>usr/local/bin</em>目录下，<em>Linux</em> 环境则拷贝到 <em>usr/bin</em>目录下。</p><h4 id="初步体验"><a href="#初步体验" class="headerlink" title="初步体验"></a>初步体验</h4><p>先来一个例子，感受一下 <em>Selenium</em>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#simple.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入selenium 的 webdriver包，只有导入 webdriver 包我们才能使用webdriver API 进行自动化脚本的开发。</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Firefox WebDriver的实例</span></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line"><span class="comment"># driver.get()方法将导航到URL指向的页面</span></span><br><span class="line">driver.get(<span class="string">"https://www.python.org"</span>)</span><br><span class="line"><span class="comment"># 获取当前页面的源并打印，Gets the source of the current page.</span></span><br><span class="line">html_text = driver.page_source</span><br><span class="line">print(html_text)</span><br><span class="line"><span class="comment"># 关闭浏览器窗口</span></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure><p>执行代码，自动调用 <em>Firefox</em>浏览器，并访问 <a href="https://www.python.org" target="_blank" rel="noopener">https://www.python.org</a> ，控制台会输出当前页面的代码。</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/Selenium3%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/6.png" alt="www.python.org"></p><h3 id="WebDriver-API"><a href="#WebDriver-API" class="headerlink" title="WebDriver API"></a><em>WebDriver API</em></h3><h4 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h4><p>想要用 <em>WebDriver</em> 做的第一件事就是导航到一个链接。通常的方法是调用<code>get()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">browser = webdriver.Firefox()</span><br><span class="line"><span class="comment"># 声明浏览器对象</span></span><br><span class="line"><span class="comment"># browser = webdriver.Chrome()</span></span><br><span class="line"><span class="comment"># browser = webdriver.Edge()</span></span><br><span class="line"><span class="comment"># browser = webdriver.PhantomJS()</span></span><br><span class="line"><span class="comment"># browser = webdriver.Safari()</span></span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">"http://www.google.com"</span>)</span><br></pre></td></tr></table></figure><h4 id="控制窗口大小"><a href="#控制窗口大小" class="headerlink" title="控制窗口大小"></a>控制窗口大小</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置当前窗口的x，y位置</span></span><br><span class="line">driver.set_window_position(<span class="number">110</span>, <span class="number">120</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前窗口的宽度和高度</span></span><br><span class="line">driver.set_window_size(width=<span class="number">800</span>, height=<span class="number">900</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置窗口的x，y坐标以及当前窗口的高度和宽度</span></span><br><span class="line">driver.set_window_rect(x=<span class="number">10</span>, y=<span class="number">10</span>, width=<span class="number">400</span>, height=<span class="number">300</span>)</span><br><span class="line"><span class="comment"># driver.set_window_rect(width=400, height=300)</span></span><br><span class="line"><span class="comment"># driver.set_window_rect(x=10, y=10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前窗口最大化</span></span><br><span class="line">driver.maximize_window()</span><br></pre></td></tr></table></figure><h4 id="页面标题和链接"><a href="#页面标题和链接" class="headerlink" title="页面标题和链接"></a>页面标题和链接</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前网页的标题</span></span><br><span class="line">driver.title</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前网页的url</span></span><br><span class="line">driver.current_url</span><br></pre></td></tr></table></figure><h4 id="页面源"><a href="#页面源" class="headerlink" title="页面源"></a>页面源</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前页面的源，返回的是str类型</span></span><br><span class="line">driver.page_source</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回当前上下文（Native或WebView），返回的是method类型</span></span><br><span class="line">driver.context</span><br></pre></td></tr></table></figure><h4 id="窗口句柄"><a href="#窗口句柄" class="headerlink" title="窗口句柄"></a>窗口句柄</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回当前会话中所有窗口的句柄。</span></span><br><span class="line">driver.window_handles</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回当前窗口的句柄</span></span><br><span class="line">driver.current_window_handle</span><br></pre></td></tr></table></figure><h4 id="窗口切换"><a href="#窗口切换" class="headerlink" title="窗口切换"></a>窗口切换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过window_handles来遍历</span></span><br><span class="line"><span class="keyword">for</span> handle <span class="keyword">in</span> driver.window_handles:</span><br><span class="line">    driver.switch_to_window(handle)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换窗口</span></span><br><span class="line">driver.switch_to.window(<span class="string">"窗口名"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或通过window_handles来遍历</span></span><br><span class="line"><span class="keyword">for</span> handle <span class="keyword">in</span> driver.window_handles:</span><br><span class="line">    driver.switch_to_window(handle)</span><br></pre></td></tr></table></figure><h4 id="历史和选项卡管理"><a href="#历史和选项卡管理" class="headerlink" title="历史和选项卡管理"></a>历史和选项卡管理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前进</span></span><br><span class="line">driver.forward()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回退</span></span><br><span class="line">driver.back()</span><br></pre></td></tr></table></figure><p>选项卡管理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行JavaScript脚本</span></span><br><span class="line">browser.execute_script(<span class="string">'window.open()'</span>)</span><br><span class="line">print(browser.window_handles)</span><br><span class="line"><span class="comment"># 切换到第二个选项卡</span></span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">1</span>])</span><br><span class="line">browser.get(<span class="string">'https://www.keymou.wang'</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 再切换到第一个选项卡</span></span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">0</span>])</span><br><span class="line">browser.get(<span class="string">'https://python.org/'</span>)</span><br></pre></td></tr></table></figure><h4 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h4><p><em>Selenium</em> 提供了以下方法定位页面中的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据id 定位元素，查找 id="SL_balloon_obj"的元素，返回id属性值与位置匹配的第一个元素</span></span><br><span class="line">driver.find_element_by_id(<span class="string">'SL_balloon_obj'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据name 定位元素</span></span><br><span class="line">driver.find_element_by_name(<span class="string">'viewport'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据xpath 定位元素，XPath是用于在XML文档中定位节点的语言。由于HTML可以是XML（XHTML）的实现，因此Selenium用户可以利用这种强大的语言来定位其Web应用程序中的元素。</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">'/html/head/meta[3]'</span>)</span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//form[1]"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据链接的文本来定位</span></span><br><span class="line">driver.find_element_by_link_text(<span class="string">'Download'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据元素标签对之间的部分文本信息来定位</span></span><br><span class="line">driver.find_element_by_partial_link_text(<span class="string">'帮助'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过tag定位</span></span><br><span class="line">driver.find_element_by_tag_name(<span class="string">'li'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据class定位</span></span><br><span class="line">driver.find_element_by_class_name(<span class="string">'FRAME_login'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据css定位</span></span><br><span class="line">driver.find_element_by_css_selector(<span class="string">'head &gt; meta:nth-child(5)'</span>)</span><br></pre></td></tr></table></figure><p>要查找多个元素，有以下方法（将 <strong><em>element</em></strong> 改为 <strong><em>elements</em></strong>），不同是这些方法返回一个列表<em>list</em> 类型，可通过索引的方式引用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据id 查找所有id="SL_balloon_obj"的元素</span></span><br><span class="line">obj = driver.find_elements_by_id(<span class="string">'SL_balloon_obj'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定引用第二个 id="SL_balloon_obj"的元素并清空元素</span></span><br><span class="line">obj[<span class="number">1</span>].clear()</span><br></pre></td></tr></table></figure><p>除了上述给出的公共方法之外，还有两个私有方法可能对页面对象中的定位有用。这是两个私有方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment"># find_element()方法</span></span><br><span class="line">driver.find_element(By.ID, <span class="string">'SL_balloon_obj'</span>)</span><br><span class="line"><span class="comment"># find_elements()方法</span></span><br><span class="line">driver.find_elements(By.NAME, <span class="string">'WB_miniblog'</span>)</span><br></pre></td></tr></table></figure><p>这些是 <em>By</em>类可用的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ID = <span class="string">"id"</span></span><br><span class="line">XPATH = <span class="string">"xpath"</span></span><br><span class="line">LINK_TEXT = <span class="string">"link text"</span></span><br><span class="line">PARTIAL_LINK_TEXT = <span class="string">"partial link text"</span></span><br><span class="line">NAME = <span class="string">"name"</span></span><br><span class="line">TAG_NAME = <span class="string">"tag name"</span></span><br><span class="line">CLASS_NAME = <span class="string">"class name"</span></span><br><span class="line">CSS_SELECTOR = <span class="string">"css selector"</span></span><br></pre></td></tr></table></figure><p><em>Selenium</em> 定位到结点位置会返回一个<em>WebElement</em> 类型的对象，可以调用下述方法来提取需要的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">element = driver.find_element_by_id(<span class="string">'downloads'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取属性class的值</span></span><br><span class="line">element.get_attribute(<span class="string">'class'</span>)</span><br><span class="line"><span class="comment"># 获取文本</span></span><br><span class="line">element.text</span><br><span class="line"><span class="comment"># 获取标签名称</span></span><br><span class="line">element.tag_name</span><br><span class="line"><span class="comment"># 获取结点id</span></span><br><span class="line">element.id</span><br><span class="line"><span class="comment"># 获取位置</span></span><br><span class="line">element.location</span><br><span class="line"><span class="comment"># 获取大小</span></span><br><span class="line">element.size</span><br></pre></td></tr></table></figure><h4 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.refresh()</span><br></pre></td></tr></table></figure><h4 id="页面交互"><a href="#页面交互" class="headerlink" title="页面交互"></a>页面交互</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># clear()用于清除文本输入框中的内容</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"idinput"</span>).clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># send_keys()用于模拟键盘向输入框里输入内容</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"input"</span>).send_keys(<span class="string">"username"</span>)</span><br><span class="line"><span class="comment"># send_keys(Keys.CONTROL, 'a')模拟键盘Ctrl+A操作</span></span><br><span class="line">driver.find_element_by_id(<span class="string">'q'</span>).send_keys(Keys.CONTROL, <span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># click()用于进行点击操作</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"loginbtn"</span>).click()</span><br></pre></td></tr></table></figure><h4 id="填写表格，提交表单"><a href="#填写表格，提交表单" class="headerlink" title="填写表格，提交表单"></a>填写表格，提交表单</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在页面上找到第一个“SELECT”元素</span></span><br><span class="line">element = driver.find_element_by_xpath(<span class="string">"//select[@name='name']"</span>)</span><br><span class="line"><span class="comment"># 依次遍历每个OPTION，打印出它们的值，然后依次选择每个OPTION。</span></span><br><span class="line">all_options = element.find_elements_by_tag_name(<span class="string">"option"</span>)</span><br><span class="line"><span class="keyword">for</span> option <span class="keyword">in</span> all_options:</span><br><span class="line">    print(<span class="string">"Value is: %s"</span> % option.get_attribute(<span class="string">"value"</span>))</span><br><span class="line">    option.click()</span><br></pre></td></tr></table></figure><p>这不是处理<em>SELECT</em> 元素的最有效方法，<em>WebDriver </em>的支持类包括一个名为 <em>Select</em> 的支持类，它提供了与这些类交互的有用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line">select = Select(driver.find_element_by_name(<span class="string">'name'</span>))</span><br><span class="line">select.select_by_index(index)</span><br><span class="line">select.select_by_value(value)</span><br><span class="line">select.select_by_visible_text(<span class="string">"text"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消选择选定选项</span></span><br><span class="line">select.deselect_by_index()</span><br><span class="line"><span class="comment"># 取消选择所有选定选项</span></span><br><span class="line">select.deselect_all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有默认选定选项的列表</span></span><br><span class="line">select = Select(driver.find_element_by_xpath(<span class="string">"//select[@name='name']"</span>))</span><br><span class="line">all_selected_options = select.all_selected_options</span><br><span class="line"><span class="comment"># 获得所有可用选项</span></span><br><span class="line">options = select.options</span><br></pre></td></tr></table></figure><p>填写完表单后，您可能想要提交表单。一种方法是找到“提交”按钮并单击它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交表单</span></span><br><span class="line"><span class="comment"># Assume the button has the ID "submit" :)</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"submit"</span>).click()</span><br></pre></td></tr></table></figure><p>另外一种方法，WebDriver在每个元素上都有“提交”的便捷方法。如果在表单中的元素上调用它，WebDriver 将向上走DOM，直到找到封闭的表单，然后调用submit。但如果元素不在表单中，则会引发异常<code>NoSuchElementException</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过定位搜索框并通过submit()提交搜索框的内容，达到点击搜索按钮的效果</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"query"</span>).submit()</span><br></pre></td></tr></table></figure><h4 id="模拟键盘输入"><a href="#模拟键盘输入" class="headerlink" title="模拟键盘输入"></a>模拟键盘输入</h4><p><code>send_keys()</code>方法虽然可以模拟键盘输入，但除此之外，还需要输入其它键，比如空格，这个时候就用到 <code>Keys()</code>,对应类：<code>selenium.webdriver.common.keys.Keys</code>，使用方法：<code>send_keys(*keys_to_send)</code> 。类似的方法还有 <code>send_keys_to_element(element, *keys_to_send)</code></p><table><thead><tr><th style="text-align:left">按键</th><th>详细描述</th></tr></thead><tbody><tr><td style="text-align:left">BACK_SPACE</td><td>删除键（BackSpace）</td></tr><tr><td style="text-align:left">SPACE</td><td>空格键（Space）</td></tr><tr><td style="text-align:left">TAB</td><td>制表键（TAB）</td></tr><tr><td style="text-align:left">ESCAPE</td><td>回退键（Esc）</td></tr><tr><td style="text-align:left">ENTER</td><td>回车键（Enter）</td></tr><tr><td style="text-align:left">CONTROL，’a’</td><td>全选（Ctrl+A）</td></tr><tr><td style="text-align:left">CONTROL，’c’</td><td>复制（Ctrl+C）</td></tr><tr><td style="text-align:left">CONTROL，’x’</td><td>剪切（Ctrl+X）</td></tr><tr><td style="text-align:left">CONTROL，’v’</td><td>粘贴（Ctrl+V）</td></tr><tr><td style="text-align:left">ARROW_DOWN</td><td>⬇</td></tr><tr><td style="text-align:left">F1</td><td>键盘F1</td></tr><tr><td style="text-align:left">…</td><td>…</td></tr><tr><td style="text-align:left">F12</td><td>键盘F12</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全选CTRL+A</span></span><br><span class="line">element.send_key(Keys.CONTROL, <span class="string">'a'</span>)</span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">element.send_key(Keys.BACK_SPACE)</span><br></pre></td></tr></table></figure><h4 id="动作链（Action-Chains）"><a href="#动作链（Action-Chains）" class="headerlink" title="动作链（Action Chains）"></a>动作链（<em>Action Chains</em>）</h4><p><em>ActionChains</em> 是一种自动执行低级别交互的方法，例如鼠标移动，鼠标按钮操作，按键和上下文菜单交互。这对于执行更复杂的操作非常有用，例如悬停和拖放。生成用户操作，在<em>ActionChains</em> 对象上调用操作方法时，操作将存储在<em>ActionChains</em> 对象的队列中。当您调用<code>perform()</code>时，事件将按它们排队的顺序触发。</p><p><em>ActionChains</em> 可用于链式模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">menu = driver.find_element_by_css_selector(<span class="string">".nav"</span>)</span><br><span class="line">hidden_submenu = driver.find_element_by_css_selector(<span class="string">".nav #submenu1"</span>)</span><br><span class="line">actions = ActionChains(driver)</span><br><span class="line"><span class="comment"># 模拟先移动鼠标到menu元素，并点击hidden_submenu元素</span></span><br><span class="line">actions.move_to_element(menu).click(hidden_submenu).perform()</span><br></pre></td></tr></table></figure><p>或者可以逐个排队，然后执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu = driver.find_element_by_css_selector(<span class="string">".nav"</span>)</span><br><span class="line">hidden_submenu = driver.find_element_by_css_selector(<span class="string">".nav #submenu1"</span>)</span><br><span class="line"></span><br><span class="line">actions = ActionChains(driver)</span><br><span class="line">actions.move_to_element(menu)</span><br><span class="line">actions.click(hidden_submenu)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure><p><em>ActionChains</em> 可以模拟鼠标动作，提供很多方法，如单击、双击、拖拽等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入ActionChains类</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">actions = ActionChains(driver)</span><br><span class="line"><span class="comment"># 单击某个节点，若click()传入None，则点击鼠标当前位置</span></span><br><span class="line">actions.click(element)</span><br><span class="line"><span class="comment"># 单击某个节点并按住鼠标左键不放</span></span><br><span class="line">actions.clcik_and_hold(element)</span><br><span class="line"><span class="comment"># 右键单击某个节点</span></span><br><span class="line">actions.context_click(element)</span><br><span class="line"><span class="comment"># 双击某个节点</span></span><br><span class="line">actions.double_click(element)</span><br><span class="line"></span><br><span class="line">source = driver.find_element_by_css_selector(<span class="string">'#droppable'</span>)</span><br><span class="line">target = driver.find_element_by_css_selector(<span class="string">'#draggable'</span>)</span><br><span class="line"><span class="comment"># 在source节点按住鼠标左键，移动鼠标到target节点并松开鼠标左键</span></span><br><span class="line">actions.drag_and_drop(source, target)</span><br><span class="line"><span class="comment"># 在source节点按住鼠标左键，按照偏移量xoffset,yoffset移动鼠标后，松开鼠标左键</span></span><br><span class="line">actions.drag_and_drop_by_offset(source, xoffset, yoffset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># key_down()按下特殊键 (Control, Alt and Shift)，key_up()释放特殊键</span></span><br><span class="line">actions.key_down(Keys.CONTROL).send_keys(<span class="string">'c'</span>).key_up(Keys.CONTROL).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照偏移量移动鼠标</span></span><br><span class="line">actions.move_by_offset(xoffset, yoffset)</span><br><span class="line"><span class="comment"># 鼠标移动到某个节点的位置</span></span><br><span class="line">actions.move_to_element(element)</span><br><span class="line"><span class="comment"># 将鼠标移动指定元素的偏移量，偏移量相对于元素的左上角</span></span><br><span class="line">actions.move_to_element_with_offset(to_element, xoffset, yoffset)</span><br><span class="line"><span class="comment"># 在几秒钟内暂停指定持续时间内的所有输入</span></span><br><span class="line">actions.pause(seconds)</span><br><span class="line"><span class="comment"># 执行所有存储的操作，调用perform()才会执行</span></span><br><span class="line">actions.perform()</span><br><span class="line"><span class="comment"># 释放鼠标按钮</span></span><br><span class="line">actions.release()</span><br><span class="line"><span class="comment"># 清除已存储在本地和远程端的操作</span></span><br><span class="line">actions.reset_actions()</span><br><span class="line"><span class="comment"># 将键发送到当前聚焦元素</span></span><br><span class="line">actions.send_keys()</span><br><span class="line"><span class="comment"># 将键发送到元素</span></span><br><span class="line">actions.send_keys_to_element(element, Keys.NUMPAD8)</span><br></pre></td></tr></table></figure><h4 id="触摸动作（Touch-Actions）"><a href="#触摸动作（Touch-Actions）" class="headerlink" title="触摸动作（Touch Actions）"></a>触摸动作（<em>Touch Actions</em>）</h4><p><em>Touch Actions</em> 与<em>ActionChains</em> 类似，模拟用户触摸动作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.touch_actions <span class="keyword">import</span> TouchActions</span><br><span class="line"></span><br><span class="line">touch = TouchActions(driver)</span><br><span class="line"><span class="comment"># 点击给定元素</span></span><br><span class="line">touch.tap()</span><br><span class="line"><span class="comment"># 在给定坐标处向下触摸</span></span><br><span class="line">touch.tap_and_hold()</span><br><span class="line"><span class="comment"># 在某一节点上双击</span></span><br><span class="line">touch.double_tap(on_element)</span><br><span class="line"><span class="comment"># 轻弹，从屏幕上的任何地方开始</span></span><br><span class="line">touch.flick(xspeed, yspeed)</span><br><span class="line"><span class="comment"># 从on_element开始轻弹，然后以指定的速度移动xoffset和yoffset</span></span><br><span class="line">touch.flick_element(on_element, xoffset, yoffset, speed)</span><br><span class="line"><span class="comment"># 长按on_element</span></span><br><span class="line">touch.long_press(on_element)</span><br><span class="line"><span class="comment"># 将保持点击移动到指定位置</span></span><br><span class="line">touch.move(xcoord, ycoord)</span><br><span class="line"><span class="comment"># 执行所有存储的操作</span></span><br><span class="line">touch.release()</span><br><span class="line"><span class="comment"># 触摸并滚动，按xoffset和yoffset移动</span></span><br><span class="line">touch.scroll(xoffset, yoffset)</span><br><span class="line"><span class="comment"># 触摸并滚动从on_element开始，按xoffset和yoffset移动</span></span><br><span class="line">touch.scroll_from_element(on_element, xoffset, yoffset)</span><br><span class="line">touch.perform()</span><br><span class="line"><span class="comment"># 在指定位置释放先前发出的tap和hold命令</span></span><br></pre></td></tr></table></figure><h4 id="页面等待"><a href="#页面等待" class="headerlink" title="页面等待"></a>页面等待</h4><p>目前，大多数<em>Web</em> 应用程序都在使用<em>AJAX</em> 技术。当浏览器加载页面时，该页面中的元素可能以不同的时间间隔加载。这使定位元素变得困难：如果<em>DOM</em> 中尚未存在元素，则将引发<em>ElementNotVisibleException</em> 异常。</p><p>为了避免这种元素定位困难而且会提高产生<em>ElementNotVisibleException</em> 的概率。<em>Selenium Webdriver</em> 提供两种类型的等待方式：<strong><em>隐式等待</em></strong>、<strong><em>显式等待</em></strong>。</p><ul><li><p>隐式等待</p><p>隐式等待比较简单，<em>WebDriver</em> 在尝试查找不能立即可用的任何元素时轮询<em>DOM</em> 一段时间。默认设置为0，设置后，将为<em>WebDriver</em> 对象的生命周期设置隐式等待。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line"><span class="comment"># 隐式等待 10s</span></span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">driver.get(<span class="string">"https://somedomain/url_that_delays_loading"</span>)</span><br><span class="line">myDynamicElement = driver.find_element_by_id(<span class="string">"myDynamicElement"</span>)</span><br></pre></td></tr></table></figure></li><li><p>显示等待</p><p>显示等待是定义的代码，用于在进一步执行代码之前等待某个条件发生。最极端情况是 <code>time.sleep()</code>，将等待时间设置为等待的确切时间。<em>WebDriverWait</em> 与 <em>ExpectedCondition</em> 相结合是一种可实现的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.get(<span class="string">"https://somedomain/url_that_delays_loading"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 抛出TimeoutException之前等待最多10秒，除非它发现元素在10秒内返回</span></span><br><span class="line">    element = WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">        EC.presence_of_element_located((By.ID, <span class="string">"myDynamicElement"</span>))</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure><p>默认情况下，<em>WebDriverWait</em> 每<em>500</em> 毫秒调用一次 <em>ExpectedCondition</em>，直到成功返回。</p><p><em>expected_conditions</em> 模块包含一组用于<em>WebDriverWait</em> 的预定义条件，具体描述如下：</p></li></ul><table><thead><tr><th style="text-align:left">预期条件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><em>title_is</em></td><td style="text-align:left">标题是某内容</td></tr><tr><td style="text-align:left"><em>title_contains</em></td><td style="text-align:left">标题包含某内容</td></tr><tr><td style="text-align:left"><em>presence_of_element_located</em></td><td style="text-align:left">节点加载出来，传人定位元组如(By.ID, ‘q’)</td></tr><tr><td style="text-align:left"><em>visibility_of_element_located</em></td><td style="text-align:left">节点可见，传入定位元组</td></tr><tr><td style="text-align:left"><em>visibility_of</em></td><td style="text-align:left">可见，传入节点对象</td></tr><tr><td style="text-align:left"><em>presence_of_all_elements_located</em></td><td style="text-align:left">所有结点加载出来</td></tr><tr><td style="text-align:left"><em>text_to_be_present_in_element</em></td><td style="text-align:left">某个节点文本包含某文字</td></tr><tr><td style="text-align:left"><em>text_to_be_present_in_element_value</em></td><td style="text-align:left">某个节点值包含某文字</td></tr><tr><td style="text-align:left"><em>frame_to_be_available_and_switch_to_it</em></td><td style="text-align:left">加载并切换</td></tr><tr><td style="text-align:left"><em>invisibility_of_element_located</em></td><td style="text-align:left">结点不可见</td></tr><tr><td style="text-align:left"><em>element_to_be_clickable</em></td><td style="text-align:left">节点可点击</td></tr><tr><td style="text-align:left"><em>staleness_of</em></td><td style="text-align:left">判断节点是否仍在DOM ，判断页面是否刷新</td></tr><tr><td style="text-align:left"><em>element_to_be_selected</em></td><td style="text-align:left">节点可选择，传节点对象</td></tr><tr><td style="text-align:left"><em>element_located_to_be_selected</em></td><td style="text-align:left">结点可选择，传入定位元组</td></tr><tr><td style="text-align:left"><em>element_selection_state_to_be</em></td><td style="text-align:left">传入结点对象和状态</td></tr><tr><td style="text-align:left"><em>element_located_selection_state_to_be</em></td><td style="text-align:left">传入定位元组和状态</td></tr><tr><td style="text-align:left"><em>alert_is_present</em></td><td style="text-align:left">是否出现警告</td></tr></tbody></table><p>  感受一下：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">wait = WebDriverWait(driver, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># element_to_be_clickable()方法传入定位元组</span></span><br><span class="line">element = wait.until(EC.element_to_be_clickable((By.ID, <span class="string">'someid'</span>)))</span><br><span class="line">wait.until(EC.presence_of_element_located((By.ID, <span class="string">'content_left'</span>)))</span><br></pre></td></tr></table></figure><p>  如果以上的都不符合，还可以创建自定义等待条件，可以使用带有<code>__call__</code>方法的类创建自定义等待条件，该方法在条件不匹配时返回 <em>False</em>。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">element_has_css_class</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="string">"""期望检查元素是否具有特定的css类</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  locator - 用于定位元素</span></span><br><span class="line"><span class="string">  只要有特定的css类，返回WebEmlement</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, locator, css_class)</span>:</span></span><br><span class="line">    self.locator = locator</span><br><span class="line">    self.css_class = css_class</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, driver)</span>:</span></span><br><span class="line">    element = driver.find_element(*self.locator)   <span class="comment"># Finding the referenced element</span></span><br><span class="line">    <span class="keyword">if</span> self.css_class <span class="keyword">in</span> element.get_attribute(<span class="string">"class"</span>):</span><br><span class="line">        <span class="keyword">return</span> element</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait until an element with id='myNewInput' has class 'myCSSClass'</span></span><br><span class="line">wait = WebDriverWait(driver, <span class="number">10</span>)</span><br><span class="line">element = wait.until(element_has_css_class((By.ID, <span class="string">'myNewInput'</span>), <span class="string">"myCSSClass"</span>))</span><br></pre></td></tr></table></figure><h4 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 休眠5秒</span></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h4 id="iframe切换"><a href="#iframe切换" class="headerlink" title="iframe切换"></a>iframe切换</h4><p>在<em>web</em> 应用中经常会遇到<em>frame/iframe</em> 表单嵌套页面的应用，<em>webdriver</em> 只能在一个页面上对元素识别与定位，对于frame/iframe无法直接定位；</p><p>这时候就需要通过<em>switch_to.frame()</em> 方法将当前定位的主体切换为<em>frame/iframe</em> 内嵌的的页面中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser.get(<span class="string">'https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到id="iframeResul"的iframe</span></span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    logo = browser.find_element_by_class_name(<span class="string">'logo'</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">'No Logo'</span>)</span><br><span class="line"><span class="comment"># 切换到当前frame</span></span><br><span class="line">browser.switch_to.parent_frame()</span><br><span class="line"><span class="comment"># 切换到默认内容</span></span><br><span class="line">browser.switch_to.default_content()</span><br><span class="line"></span><br><span class="line"><span class="comment"># iframe没有id或name情况，先通过find_element方法定位到iframe，然后传给switch_to.frame()方法</span></span><br><span class="line">driver.switch_to.frame(BROWSER.find_element_by_tag_name(<span class="string">'iframe'</span>))</span><br></pre></td></tr></table></figure><h4 id="弹窗示警"><a href="#弹窗示警" class="headerlink" title="弹窗示警"></a>弹窗示警</h4><p><em>Selenium WebDriver</em>内置支持处理弹出对话框。在您触发将打开弹出窗口的操作后，您可以使用以下命令访问警报：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将返回当前打开的警报对象</span></span><br><span class="line">alert = driver.switch_to_alert()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.alert <span class="keyword">import</span> Alert</span><br><span class="line"></span><br><span class="line">alert = Alert(driver)</span><br><span class="line"><span class="comment"># 接受可用的警报,确认警告对话框</span></span><br><span class="line">alert.accept()</span><br><span class="line"><span class="comment"># 驳回可用的警报</span></span><br><span class="line">alert.dismiss()</span><br><span class="line"><span class="comment"># 将键发送到警报</span></span><br><span class="line">alert.send_keys()</span><br><span class="line"><span class="comment"># 获取alert文本内容</span></span><br><span class="line">alert.text()</span><br></pre></td></tr></table></figure><h4 id="上传下载文件"><a href="#上传下载文件" class="headerlink" title="上传下载文件"></a>上传下载文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过send_keys()方法模拟上传文件</span></span><br><span class="line">driver.find_element_by_name(<span class="string">"file"</span>).send_keys(<span class="string">"unittest.txt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载文件</span></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">prefs = &#123;<span class="string">'profile.default_content_settings.popups'</span>: <span class="number">0</span>, <span class="string">'download.default_directory'</span>: os.getcwd()&#125;</span><br><span class="line">options.add_experimental_option(<span class="string">'prefs'</span>, prefs)</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(chrome_options=options)</span><br><span class="line">driver.get(<span class="string">"https://pypi.Python.org/pypi/selenium"</span>)driver.find_element_by_partial_link_text(<span class="string">"selenium-3.11.0-py2.py3-none-any"</span>).click()</span><br></pre></td></tr></table></figure><h4 id="页面截图"><a href="#页面截图" class="headerlink" title="页面截图"></a>页面截图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将当前窗口的屏幕截图保存到PNG图像文件，可以传入相对路径或绝对路径</span></span><br><span class="line">driver.save_screenshot(<span class="string">'/截图/foo.png'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取当前窗口，并指定截图图片的保存位置</span></span><br><span class="line">dirver.get_screenshot_as_file(<span class="string">"screen.jpg"</span>)</span><br><span class="line"><span class="comment"># 获取当前窗口的屏幕截图作为base64编码的字符串，适用于在HTML中的嵌入图像</span></span><br><span class="line">driver.get_screenshot_as_base64()</span><br><span class="line"><span class="comment"># 截屏并保存为png格式图片</span></span><br><span class="line">driver.get_screenshot_as_png()</span><br></pre></td></tr></table></figure><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a><em>cookie</em></h4><p>有些站点需要登录后才能访问，用<em>Selenium</em> 模拟登录后获取<em>Cookie</em>，然后供爬虫使用的场景非常常见，<em>Selenium</em>提供了获取，增加，删除<em>Cookies</em> 的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有Cookies</span></span><br><span class="line">browser.get_cookies()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取name对应的cookie信息</span></span><br><span class="line">browser.get_cookie(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加Cookies，是字典对象，必须要有name和value</span></span><br><span class="line">browers.add_cookie(&#123;xxx&#125;)</span><br><span class="line">driver.add_cookie(&#123;<span class="string">'name'</span>: <span class="string">'name'</span>, <span class="string">'domain'</span>: <span class="string">'www.zhihu.com'</span>, <span class="string">'value'</span>: <span class="string">'keymou'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要遍历，则如下：</span></span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> driver.get_cookies():</span><br><span class="line">    print(<span class="string">"%s -&gt; %s "</span> % (cookie[<span class="string">"name"</span>],cookie[<span class="string">"value"</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有Cookies</span></span><br><span class="line">browser.delete_all_cookies()</span><br><span class="line"><span class="comment"># 删除Cookie信息，name是要删除的cookie的名称，optionsString是该cookie的选项，目前支持的选项包括“路径”和“域”</span></span><br><span class="line">browser.delete_cookie(name, optionsString)</span><br></pre></td></tr></table></figure><p>实践一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line"><span class="comment"># 获取浏览器cookies</span></span><br><span class="line">cookies = browser.get_cookies()</span><br><span class="line"><span class="comment"># 打印cookies类型并打印cookies</span></span><br><span class="line">print(type(cookies))</span><br><span class="line">print(cookies)</span><br><span class="line"><span class="comment"># 构造cookies</span></span><br><span class="line"><span class="comment"># cookies字典包含name、value、path、domain、secure、httpOnly、expiry。</span></span><br><span class="line"><span class="comment"># name：cookie的名称；</span></span><br><span class="line"><span class="comment"># value：cookie对应生成的动态值；</span></span><br><span class="line"><span class="comment"># path：定义了Web服务器上哪些路径下的页面可获取服务器设置的Cookie；</span></span><br><span class="line"><span class="comment"># domain：服务器域名；</span></span><br><span class="line"><span class="comment"># secure：Cookie中标记该变量；当设置为true时，表示创建的Cookie会被以安全的形式向服务器传输</span></span><br><span class="line"><span class="comment"># httpOnly：防脚本攻击；设置为true时，则通过程序(JS脚本、Applet等)将无法读取到Cookie信息，这样能有效的防止XSS攻击。</span></span><br><span class="line"><span class="comment"># expiry：Cookie有效终止日期。</span></span><br><span class="line">cookies = &#123;</span><br><span class="line">    <span class="string">'domain'</span>: <span class="string">'www.zhihu.com'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'name'</span>,</span><br><span class="line">    <span class="string">'value'</span>: <span class="string">'keymou'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># add_cookie方法接受一个字典</span></span><br><span class="line">browser.add_cookie(cookies)</span><br><span class="line"><span class="comment"># 打印添加过cookie后的cookies</span></span><br><span class="line">print(browser.get_cookies())</span><br><span class="line"><span class="comment"># delete_all_cookies()删除cookies</span></span><br><span class="line">browser.delete_all_cookies()</span><br><span class="line"><span class="comment"># 打印cookies</span></span><br><span class="line">print(browser.get_cookies())</span><br></pre></td></tr></table></figure><p>执行代码，<em>cookies</em> 是个嵌套字典的列表。</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/Selenium3%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/7.png" alt="cookies操作示例"></p><p>在实践中我们可以通过<em>selenium</em> 模拟登录操作，然后通过对象的方法获取当前访问网站的<em>session</em>、<em>cookie</em>，得到<em>cookie</em> 之后，就可以通过<em>urllib2</em> 或<em>request</em> 访问相应的网站，并可实现网页爬取等工作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取浏览器cookies</span></span><br><span class="line">cookies = browser.get_cookies()</span><br><span class="line"><span class="comment"># 构造cookie</span></span><br><span class="line">cookie = [item[<span class="string">'name'</span>] + <span class="string">"="</span> + item[<span class="string">'value'</span>] <span class="keyword">for</span> item <span class="keyword">in</span> cookies]</span><br><span class="line">cookies = <span class="string">';'</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> cookie)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用urllib</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">url = browser.current_url</span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Fir'</span>,</span><br><span class="line">    <span class="string">'Cookie'</span>: cookies,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = request.Request(url=url, headers=header)</span><br><span class="line">response = request.urlopen(res)</span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><h4 id="执行JS-语句"><a href="#执行JS-语句" class="headerlink" title="执行JS 语句"></a>执行<em>JS</em> 语句</h4><p><em>webdriver</em> 提供浏览器的前进和后退，但是并不提供滚动浏览器的操作，因此来借助<em>JS</em> 来控制浏览器的滚动条。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用execute_script() 方法</span></span><br><span class="line">browser.execute_script(<span class="string">'window.scrollTo(0, document.body.scrollHeight)'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'alert("To bottom")'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向文本框输入文本信息</span></span><br><span class="line">text = <span class="string">"Hello world"</span></span><br><span class="line">js = <span class="string">"var sum=document.getElementById("</span>id<span class="string">"); sum.value='"</span>+text+ <span class="string">" ';"</span></span><br><span class="line">driver.excute_script(js)</span><br></pre></td></tr></table></figure><h4 id="Headless"><a href="#Headless" class="headerlink" title="Headless"></a><em>Headless</em></h4><p>在介绍<em>Headless</em>之前，必须介绍下<em>PhantomJS</em>，<em>PhantomJS</em>是没有界面的浏览器，特点：<strong>会把网站加载到内存并执行页面上的JavaScript，因为不会展示图形界面，所以运行起来比完整的浏览器要高效</strong>。</p><p>使用也简单，不过首先得下载 <em>phantomjs.exe</em>，拷贝到<em>Python\Scripts</em> 目录下，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> PhantomJS</span><br><span class="line"></span><br><span class="line">driver = PhantomJS()</span><br><span class="line">driver.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">print(driver.current_url)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><p>不过18年4月份维护者宣布退出PhantomJs，意味着这个项目不再维护了。</p><p>下面简单介绍下 <em>Chrome</em>和<em>Firefox</em> 浏览器的<em>Headless</em> 模式，<em>Windows Chrome</em>需要60以上的版本才支持 <em>Headless</em>模式，<em>linux，unix</em>系统需要 <em>chrome</em>浏览器 &gt;= 59。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''Chrome Headless模式'''</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">chrome_options = Options()</span><br><span class="line">chrome_options.add_argument(<span class="string">"--headless"</span>)</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">"https://www.baidu.com/"</span></span><br><span class="line"><span class="comment">#对应的chromedriver的放置目录</span></span><br><span class="line">driver = webdriver.Chrome(executable_path=(<span class="string">r'C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe'</span>), chrome_options=chrome_options)</span><br><span class="line"></span><br><span class="line">driver.get(base_url + <span class="string">"/"</span>)</span><br><span class="line"></span><br><span class="line">start_time=time.time()</span><br><span class="line">print(<span class="string">'this is start_time '</span>,start_time)</span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>).send_keys(<span class="string">"selenium webdriver"</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">"su"</span>).click()</span><br><span class="line">driver.save_screenshot(<span class="string">'pic\screen.png'</span>)</span><br><span class="line"></span><br><span class="line">driver.close()</span><br><span class="line"></span><br><span class="line">end_time=time.time()</span><br><span class="line">print(<span class="string">'this is end_time '</span>,end_time)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''Firefox Headless模式'''</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">options = webdriver.FirefoxOptions()</span><br><span class="line">options.add_argument(<span class="string">'-headless'</span>)</span><br><span class="line">browser = webdriver.Firefox(options=options)</span><br><span class="line">base_url = <span class="string">'https://www.weather.com.cn/'</span></span><br><span class="line">browser.get(base_url)  </span><br><span class="line">print(browser.current_url)</span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure><h4 id="Webdriver-chrome"><a href="#Webdriver-chrome" class="headerlink" title="Webdriver.chrome"></a>Webdriver.chrome</h4><h5 id="chrome-options"><a href="#chrome-options" class="headerlink" title="chrome.options"></a>chrome.options</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line">chrome_options = Options()</span><br><span class="line"><span class="comment"># 向列表加入参数</span></span><br><span class="line">chrome_options.add_argument(<span class="string">"--headless"</span>)</span><br><span class="line">chrome_options.add_argument(<span class="string">'--user-agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"'</span>)</span><br><span class="line">browser = webdriver.Chrome(chrome_options=chrome_options)</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure><p><code>add_argument()</code>方法可以添加启动参数，添加完毕后可以在初始化<em>Webdriver</em> 对象时将此<em>Options</em> 对象传入，则可以实现以特定参数启动<em>Chrome</em>。</p><p>常用的启动参数：</p><table><thead><tr><th style="text-align:center">启动参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">–user-agent=””</td><td style="text-align:center">设置请求头的User-Agent</td></tr><tr><td style="text-align:center">–window-size=1366,768</td><td style="text-align:center">设置浏览器分辨率</td></tr><tr><td style="text-align:center">–headless</td><td style="text-align:center">无界面运行</td></tr><tr><td style="text-align:center">–start-maximized</td><td style="text-align:center">最大化运行</td></tr><tr><td style="text-align:center">–incognito</td><td style="text-align:center">隐身模式</td></tr><tr><td style="text-align:center">–disable-javascript</td><td style="text-align:center">禁用javascript</td></tr><tr><td style="text-align:center">–disable-infobars</td><td style="text-align:center">禁用浏览器正在被自动化程序控制的提示</td></tr></tbody></table><p>完整启动参数可以点此<a href="https://peter.sh/experiments/chromium-command-line-switches/" target="_blank" rel="noopener">链接</a>查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 禁用图片加载</span></span><br><span class="line">prefs = &#123;</span><br><span class="line">    <span class="string">'profile.default_content_setting_values'</span> : &#123;</span><br><span class="line">        <span class="string">'images'</span> : <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">options.add_experimental_option(<span class="string">'prefs'</span>,prefs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用浏览器弹框</span></span><br><span class="line">prefs = &#123;  </span><br><span class="line">    <span class="string">'profile.default_content_setting_values'</span> :  &#123;  </span><br><span class="line">        <span class="string">'notifications'</span> : <span class="number">2</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">options.add_experimental_option(<span class="string">'prefs'</span>,prefs)</span><br></pre></td></tr></table></figure><p><strong><em>options</em></strong> 还提供其他方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将其用于提取到ChromeDriver具有扩展数据的Base64编码字符串添加到列表中</span></span><br><span class="line">chrome_options.add_encoded_extension(extension)</span><br><span class="line"><span class="comment"># 添加传送给Chrome的实验选项，name为实验选项名称，value为其值</span></span><br><span class="line">chrome_options.add_experimental_option(name, value)</span><br><span class="line"><span class="comment"># 添加扩展路径，extension: *.crx扩展文件的路径</span></span><br><span class="line">chrome_options.add_extension(extension)</span><br><span class="line"><span class="comment"># 返回arguments参数列表</span></span><br><span class="line">chrome_options.arguments</span><br><span class="line"><span class="comment"># 返回二进制文件的位置</span></span><br><span class="line">chrome_options.binary_location</span><br><span class="line"><span class="comment"># 返回远程devtools实例的地址</span></span><br><span class="line">chrome_options.debugger_address</span><br><span class="line"><span class="comment"># 返回chrome的实验选项字典</span></span><br><span class="line">chrome_options.experimental_options</span><br><span class="line"><span class="comment"># 返回将加载到chrome中的已编码扩展名列表</span></span><br><span class="line">chrome_options.extensions</span><br><span class="line"><span class="comment"># 返回是否设置headless,设置headless返回True</span></span><br><span class="line">chrome_options.headless</span><br><span class="line"><span class="comment"># 设置capalility</span></span><br><span class="line">chrome_options.set_capability(name, value)</span><br><span class="line"><span class="comment"># 设置headless</span></span><br><span class="line">chrome_options.set_headless(headless=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><h5 id="chrome-webdriver"><a href="#chrome-webdriver" class="headerlink" title="chrome.webdriver"></a>chrome.webdriver</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line">options = Options()</span><br><span class="line"><span class="comment"># 向列表加入参数</span></span><br><span class="line">options.add_argument(<span class="string">'--headless'</span>)</span><br><span class="line"><span class="comment"># Chrome()传入可传入以下参数：</span></span><br><span class="line"><span class="comment"># executable_path: chromedriver.exe的路径，方便部署项目</span></span><br><span class="line"><span class="comment"># port：端口号</span></span><br><span class="line"><span class="comment"># options：需要传入ChromeOptions实例，同chrome_options</span></span><br><span class="line"><span class="comment"># desired_capabilities：仅具有非浏览器特定功能的Dictionary对象，如“proxy”或“loggingPref”。</span></span><br><span class="line"><span class="comment"># service_args：服务器参数</span></span><br><span class="line"><span class="comment"># service_log_path：服务器日志路径</span></span><br><span class="line"><span class="comment"># keep_alive：是否保持长连接</span></span><br><span class="line">browser = webdriver.Chrome(executable_path=<span class="string">'chromedriver.exe'</span>, port=<span class="number">0</span>, options=options, service_log_path=<span class="string">'\log'</span>, keep_alive=true)</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(chrome_options=options)</span><br><span class="line"><span class="comment"># 日志类型</span></span><br><span class="line">browser.log_types()</span><br><span class="line">browser.create_options()</span><br><span class="line"><span class="comment"># 执行Chrome Devtools Protocol命令并获取返回的结果</span></span><br><span class="line">browser.execute_cdp_cmd(cmd, cmd_args)</span><br><span class="line"><span class="comment"># 获取Chrome网络仿真设置，返回类型为字典dict</span></span><br><span class="line">browser.get_network_conditions()</span><br><span class="line"><span class="comment"># 启动ID指定的Chrome应用</span></span><br><span class="line">browser.launch_app(id)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍下&lt;em&gt;Web&lt;/em&gt; 应用程序界面常用的自动化测试框架 &lt;em&gt;Selenium&lt;/em&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="selenium自动化" scheme="https://www.keymou.wang/categories/selenium%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
      <category term="python" scheme="https://www.keymou.wang/tags/python/"/>
    
      <category term="selenium" scheme="https://www.keymou.wang/tags/selenium/"/>
    
      <category term="自动化" scheme="https://www.keymou.wang/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Python 爬虫之模拟Ajax请求抓取新浪微博</title>
    <link href="https://www.keymou.wang/Python%20%E7%88%AC%E8%99%AB%E4%B9%8B%E6%A8%A1%E6%8B%9FAjax%E8%AF%B7%E6%B1%82%E6%8A%93%E5%8F%96%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A.html"/>
    <id>https://www.keymou.wang/Python 爬虫之模拟Ajax请求抓取新浪微博.html</id>
    <published>2018-12-29T03:19:58.000Z</published>
    <updated>2019-04-27T04:29:00.182Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><em>Python</em> 模拟<em>Ajax</em> 请求，抓取新浪微博。</p><a id="more"></a><h4 id="Ajax-是什么"><a href="#Ajax-是什么" class="headerlink" title="Ajax 是什么"></a><em>Ajax</em> 是什么</h4><p>全称为 <em>Asynchronous JavaScript and XML</em>，即异步的 <em>JavaScript</em> 和 <em>XML</em>，利用 <em>JavaScript</em> 在保证页面不被刷新、页面链接不变的情况下与服务器交换数据并更新部分网页的技术。</p><p>拿新浪微博为例，打开我的<a href="https://m.weibo.cn/u/1715175570" target="_blank" rel="noopener">微博链接</a>，一直下滑，可以发现下滑几个微博之后，会出现一个加载的动画，不一会儿就继续出现了新的微博内容，这个过程其实就是 <em>Ajax</em> 加载的过程。</p><h5 id="Ajax-基本原理"><a href="#Ajax-基本原理" class="headerlink" title="Ajax 基本原理"></a>Ajax 基本原理</h5><p>这里不多做介绍，详细可参考 <em>W3school</em> 关于 <a href="https://www.w3school.com.cn/ajax/index.asp" target="_blank" rel="noopener"><em>Ajax 教程</em></a></p><h4 id="分析请求"><a href="#分析请求" class="headerlink" title="分析请求"></a>分析请求</h4><p>用<em>Firefox</em> 浏览器打开我的<a href="https://m.weibo.cn/u/1715175570" target="_blank" rel="noopener">微博链接</a>，打开火狐浏览器自带的 <em>Web</em> 开发者工具，切换“网络”选项卡，可以发现这里出现很多条请求。<em>Ajax</em> 的请求类型是 <em>xhr</em>，可以通过工具栏上不同请求类型如 <em>HTML、CSS、JS、XHR</em> 等过滤请求。</p><p>点击”<em>XHR</em>“ 类型，过滤出 <em>Ajax</em> 请求再做分析。点击其中一条，可以查询该条请求的详细。在“消息头”选项卡中查看 请求网址，请求方法，以及请求头的详细，<code>X-Requested-With</code> 是 <code>XMLHttpRequest</code>，这就标记了此请求是 <em>Ajax</em> 请求。</p><p>随后可点击下 ”响应“，可以看到 <em>JSON</em> 格式的响应内容，返回的是个人信息，如昵称、简介等，这也是用来渲染个人主页所用的数据。下滑页面以加载新的微博内容，可以看到，会有不断的 Ajax 请求发出。选择其中一个请求，分析它的参数信息。这是一个 <em>GET</em> 请求，请求链接是 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://m.weibo.cn/api/container/getIndex?type=uid&amp;value=1715175570&amp;containerid=1076031715175570&amp;page=2</span><br></pre></td></tr></table></figure><p>分析链接，请求的参数有 4 个：<em>type、value、containerid、page</em>。</p><p>继续看接下来的请求，可以发现，<em>type、value、containerid</em> 始终没有变化，改变的值只有 <strong><em>page</em></strong>，很明显这个参数用来控制分页的，下图所示。</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/Python%20%E6%A8%A1%E6%8B%9F%20Ajax%20%E8%AF%B7%E6%B1%82%E6%8A%93%E5%8F%96%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A/1.jpg" alt="Ajax请求分析"></p><h4 id="分析响应"><a href="#分析响应" class="headerlink" title="分析响应"></a>分析响应</h4><p>观察这个请求的响应内容，所图所示：</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/Python%20%E6%A8%A1%E6%8B%9F%20Ajax%20%E8%AF%B7%E6%B1%82%E6%8A%93%E5%8F%96%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A/2.jpg" alt="response"></p><p>响应内容是 <em>JSON</em> 格式的，data 数据分为两部分：<em>cardlilstInfo、cards</em>。<strong><em>cards</em></strong> 是一个列表，包含要提取的微博信息，比较重要的字段是 <em>mblog</em>。 包含的是微博一些信息，如 <em>created_at（发布日期）、reposts_count（转发数目）、comments_count（评论数目）、attitudes_count（点赞数目）、text（微博正文）</em>等。</p><p>这样可以构造请求一个接口，就可以获得一个 <em>page</em> 的微博，只需改变参数 <em>page</em> 即可。</p><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><p>可以先定义一个获取单个 <em>page</em> 的函数 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">        <span class="string">'Host'</span>: <span class="string">'m.weibo.cn'</span>,</span><br><span class="line">        <span class="string">'Referer'</span>: <span class="string">'https://m.weibo.cn/u/1715175570'</span>,</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0;) Gecko/20100101 Firefox/63.0'</span>,</span><br><span class="line">        <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(page)</span>:</span></span><br><span class="line">    <span class="string">"""获取页面page微博列表"""</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">'type'</span>:<span class="string">'uid'</span>,</span><br><span class="line">        <span class="string">'value'</span>: <span class="string">'1715175570'</span>,</span><br><span class="line">        <span class="string">'containerid'</span>: <span class="string">'1076031715175570'</span>,</span><br><span class="line">        <span class="string">'page'</span>: page</span><br><span class="line">    &#125;</span><br><span class="line">    url = base_url + urlencode(params)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.json()</span><br><span class="line">    <span class="keyword">except</span> requests.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'Error'</span>, e.args)</span><br></pre></td></tr></table></figure><p>这里定义 <em>base_url</em> 来表示请求的 <em>URL</em> 前半部分，接下来，构造参数字典，调用 <em>urlencode()</em> 方法将参数转换成 <em>URL</em> 的 <em>GET</em> 请求参数。随后，<em>base_url</em> 与参数拼接成完整的 <em>URL</em> 。</p><p>用<em>requests</em> 请求这个链接，加入<em>headers</em> 参数，然后判断响应的状态码，若请求成功，返回<em>200</em>，则调用<em>json()</em> 方法将内容解析为 <em>JSON</em> 返回，否则不返回任何信息。</p><p>之后定义一个解析方法 <em>parse_page(json)</em>，用来从返回的 <em>JSON</em> 中提取信息，遍历 <em>cards</em>，获取 <em>mblog</em> 中的各个信息，赋值为一个信息的字典返回即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(json)</span>:</span></span><br><span class="line">    <span class="string">"""解析网页"""</span></span><br><span class="line">    <span class="keyword">if</span> json:</span><br><span class="line">        items = json.get(<span class="string">'data'</span>).get(<span class="string">'cards'</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            item = item.get(<span class="string">'mblog'</span>)</span><br><span class="line">            weibo = &#123;&#125;</span><br><span class="line">            <span class="comment"># 发布日期</span></span><br><span class="line">            weibo[<span class="string">'date'</span>] = item.get(<span class="string">'created_at'</span>)</span><br><span class="line">            weibo[<span class="string">'id'</span>] = item.get(<span class="string">'id'</span>)</span><br><span class="line">            <span class="comment"># 微博正文</span></span><br><span class="line">            weibo[<span class="string">'text'</span>] = pq(item.get(<span class="string">'text'</span>)).text()</span><br><span class="line">            weibo[<span class="string">'source'</span>] = item.get(<span class="string">'source'</span>)</span><br><span class="line">            <span class="comment"># 转发数</span></span><br><span class="line">            weibo[<span class="string">'reposts'</span>] = item.get(<span class="string">'reposts_count'</span>)</span><br><span class="line">            <span class="comment"># 评论数</span></span><br><span class="line">            weibo[<span class="string">'comments'</span>] = item.get(<span class="string">'comments_count'</span>)</span><br><span class="line">            <span class="comment"># 点赞数</span></span><br><span class="line">            weibo[<span class="string">'attitudes'</span>] = item.get(<span class="string">'attitudes_count'</span>)</span><br><span class="line">            <span class="keyword">yield</span> weibo</span><br></pre></td></tr></table></figure><p>然后再定义一个方法将解析出来的结果储存到 <em>MongoDB</em> 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_mongo</span><span class="params">(result)</span>:</span></span><br><span class="line">    <span class="string">"""将返回结果result保存到MongoDB"""</span></span><br><span class="line">    <span class="keyword">if</span> collection.insert_many(result):</span><br><span class="line">        print(<span class="string">'Saved to mongodb'</span>)</span><br></pre></td></tr></table></figure><p>另外定义一个获取长微博全文内容的方法，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longtext</span><span class="params">(id)</span>:</span></span><br><span class="line">    <span class="string">"""获取长微博内容"""</span></span><br><span class="line">    url = <span class="string">'https://m.weibo.cn/statuses/extend?id='</span> + id</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            longtext = response.json().get(<span class="string">'data'</span>).get(<span class="string">'longTextContent'</span>)</span><br><span class="line">            <span class="keyword">return</span> pq(longtext).text()</span><br><span class="line">    <span class="keyword">except</span> requests.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'Error'</span>, e.args)</span><br></pre></td></tr></table></figure><p>需要传入一个 <em>id</em> 参数，配合改写下解析方法<em>parse_page(json)</em> ，整合代码，完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(json)</span>:</span></span><br><span class="line">    <span class="string">"""解析网页"""</span></span><br><span class="line">    <span class="keyword">if</span> json:</span><br><span class="line">        items = json.get(<span class="string">'data'</span>).get(<span class="string">'cards'</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                item = item.get(<span class="string">'mblog'</span>)</span><br><span class="line">                weibo = &#123;&#125;</span><br><span class="line">                <span class="comment"># 创建日期</span></span><br><span class="line">                weibo[<span class="string">'date'</span>] = item.get(<span class="string">'created_at'</span>)</span><br><span class="line">                weibo[<span class="string">'id'</span>] = item.get(<span class="string">'id'</span>)</span><br><span class="line">                <span class="comment"># 判断是否为长微博</span></span><br><span class="line">                <span class="keyword">if</span> item.get(<span class="string">'isLongText'</span>) == <span class="keyword">True</span>:</span><br><span class="line">                    content = pq(item.get(<span class="string">'text'</span>))</span><br><span class="line">                    result = re.search(<span class="string">r'&lt;a.*?status.*?(\d&#123;16&#125;).*?"'</span>, str(content))</span><br><span class="line">                    lt_id = result.group(<span class="number">1</span>)</span><br><span class="line">                    weibo[<span class="string">'text'</span>] = longtext(lt_id)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 微博正文</span></span><br><span class="line">                    weibo[<span class="string">'text'</span>] = pq(item.get(<span class="string">'text'</span>)).text()</span><br></pre></td></tr></table></figure><p>修改下 <em>get_page()</em> 方法，将 <em>value、containerid</em> 同样做了参数化处理，这样可以方便爬取其他微博用户的信息。值得注意的是，返回的 <em>JSON</em> 内容在遍历<em>cards</em> 时可能会报错，原因在于微博有时会在 <em>cards</em> 列表中返回博主关注的信息，导致在解析时报 <em>AttributeError</em>，故在<em>parse_page()</em> 方法加上异常处理、以及抓取了转发微博的原微博内容。</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/Python%20%E6%A8%A1%E6%8B%9F%20Ajax%20%E8%AF%B7%E6%B1%82%E6%8A%93%E5%8F%96%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A/3.jpg" alt=""></p><p>最后在 <em>main()</em> 中通过 <em>while</em> 循环实现遍历所有页的微博内容。</p><h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><p><img src="https://github.com/keymou/blog_images/raw/master/content/Python%20%E6%A8%A1%E6%8B%9F%20Ajax%20%E8%AF%B7%E6%B1%82%E6%8A%93%E5%8F%96%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A/4.jpg" alt="执行结果"></p><p><strong><em>Studio 3T</em></strong> 客户端展示结果如下：</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/Python%20%E6%A8%A1%E6%8B%9F%20Ajax%20%E8%AF%B7%E6%B1%82%E6%8A%93%E5%8F%96%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A/5.jpg" alt="Studio 3T展示结果"></p><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">获取微博</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(value, containerid, page)</span>:</span></span><br><span class="line">    <span class="string">"""获取页面微博列表"""</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">'type'</span>:<span class="string">'uid'</span>,</span><br><span class="line">        <span class="string">'value'</span>: value,</span><br><span class="line">        <span class="string">'containerid'</span>: containerid,</span><br><span class="line">        <span class="string">'page'</span>: page</span><br><span class="line">    &#125;</span><br><span class="line">    url = base_url + urlencode(params)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.json()</span><br><span class="line">    <span class="keyword">except</span> requests.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'Error'</span>, e.args)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(json)</span>:</span></span><br><span class="line">    <span class="string">"""解析网页"""</span></span><br><span class="line">    <span class="keyword">if</span> json:</span><br><span class="line">        items = json.get(<span class="string">'data'</span>).get(<span class="string">'cards'</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                item = item.get(<span class="string">'mblog'</span>)</span><br><span class="line">                weibo = &#123;&#125;</span><br><span class="line">                <span class="comment"># 创建日期</span></span><br><span class="line">                weibo[<span class="string">'date'</span>] = item.get(<span class="string">'created_at'</span>)</span><br><span class="line">                weibo[<span class="string">'id'</span>] = item.get(<span class="string">'id'</span>)</span><br><span class="line">                <span class="comment"># 判断是否为长微博</span></span><br><span class="line">                <span class="keyword">if</span> item.get(<span class="string">'isLongText'</span>) == <span class="keyword">True</span>:</span><br><span class="line">                    content = pq(item.get(<span class="string">'text'</span>))</span><br><span class="line">                    result = re.search(<span class="string">r'&lt;a.*?status.*?(\d&#123;16&#125;).*?"'</span>, str(content))</span><br><span class="line">                    lt_id = result.group(<span class="number">1</span>)</span><br><span class="line">                    weibo[<span class="string">'text'</span>] = longtext(lt_id)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 微博正文</span></span><br><span class="line">                    weibo[<span class="string">'text'</span>] = pq(item.get(<span class="string">'text'</span>)).text()</span><br><span class="line">                weibo[<span class="string">'source'</span>] = item.get(<span class="string">'source'</span>)</span><br><span class="line">                <span class="comment"># 转发数</span></span><br><span class="line">                weibo[<span class="string">'reposts'</span>] = item.get(<span class="string">'reposts_count'</span>)</span><br><span class="line">                <span class="comment"># 评论数</span></span><br><span class="line">                weibo[<span class="string">'comments'</span>] = item.get(<span class="string">'comments_count'</span>)</span><br><span class="line">                <span class="comment"># 点赞数</span></span><br><span class="line">                weibo[<span class="string">'attitudes'</span>] = item.get(<span class="string">'attitudes_count'</span>)</span><br><span class="line">                <span class="comment"># 转发原文内容</span></span><br><span class="line">                <span class="keyword">if</span> item.get(<span class="string">'retweeted_status'</span>):</span><br><span class="line">                    weibo[<span class="string">'repost_text'</span>] = pq(item.get(<span class="string">'retweeted_status'</span>).get(<span class="string">'text'</span>)).text()</span><br><span class="line">            <span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">yield</span> weibo</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longtext</span><span class="params">(id)</span>:</span></span><br><span class="line">    <span class="string">"""获取长微博内容"""</span></span><br><span class="line">    url = <span class="string">'https://m.weibo.cn/statuses/extend?id='</span> + id</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            longtext = response.json().get(<span class="string">'data'</span>).get(<span class="string">'longTextContent'</span>)</span><br><span class="line">            <span class="comment"># 通过pyquery方法去掉一些html标签</span></span><br><span class="line">            <span class="keyword">return</span> pq(longtext).text()</span><br><span class="line">    <span class="keyword">except</span> requests.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'Error'</span>, e.args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_mongo</span><span class="params">(result)</span>:</span></span><br><span class="line">    <span class="string">"""将返回结果result保存到MongoDB"""</span></span><br><span class="line">    <span class="keyword">if</span> collection.insert_many(result):</span><br><span class="line">        print(<span class="string">'Saved to mongodb'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    value = <span class="string">'1862855661'</span></span><br><span class="line">    containerid = <span class="string">'1076031862855661'</span></span><br><span class="line">    base_url = <span class="string">'https://m.weibo.cn/api/container/getIndex?'</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'Host'</span>: <span class="string">'m.weibo.cn'</span>,</span><br><span class="line">        <span class="string">'Referer'</span>: <span class="string">'https://m.weibo.cn/u/'</span> + value,</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0;) Gecko/20100101 Firefox/63.0'</span>,</span><br><span class="line">        <span class="string">'X-Requested-With'</span>: <span class="string">'XMLHttpRequest'</span></span><br><span class="line">    &#125;</span><br><span class="line">    myclient = MongoClient(<span class="string">"mongodb://localhost:27017/"</span>)</span><br><span class="line">    mydb = myclient[<span class="string">"test"</span>]</span><br><span class="line">    collection = mydb[<span class="string">"weibo"</span> + value]</span><br><span class="line">    page = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        print(<span class="string">'*'</span>*<span class="number">50</span>)</span><br><span class="line">        print(<span class="string">'正在爬取：第%s 页'</span> %page)</span><br><span class="line">        json = get_page(value, containerid, page)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> json.get(<span class="string">'ok'</span>) == <span class="number">0</span>:</span><br><span class="line">            results = parse_page(json)</span><br><span class="line">            save_to_mongo(results)</span><br><span class="line">            page += <span class="number">1</span></span><br><span class="line">            time.sleep(random.randint(<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"下载完最后一页!"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Python&lt;/em&gt; 模拟&lt;em&gt;Ajax&lt;/em&gt; 请求，抓取新浪微博。&lt;/p&gt;
    
    </summary>
    
      <category term="Python爬虫" scheme="https://www.keymou.wang/categories/Python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python爬虫" scheme="https://www.keymou.wang/tags/python%E7%88%AC%E8%99%AB/"/>
    
      <category term="MongoDB" scheme="https://www.keymou.wang/tags/MongoDB/"/>
    
      <category term="Ajax" scheme="https://www.keymou.wang/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>Python 爬虫之利用requests库抓取猫眼电影排行</title>
    <link href="https://www.keymou.wang/Python%20%E7%88%AC%E8%99%AB%E4%B9%8B%E5%88%A9%E7%94%A8requests%E5%BA%93%E6%8A%93%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8E%92%E8%A1%8C.html"/>
    <id>https://www.keymou.wang/Python 爬虫之利用requests库抓取猫眼电影排行.html</id>
    <published>2018-12-26T02:18:58.000Z</published>
    <updated>2019-04-27T03:51:16.215Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>通过<em>requests</em>库，正则表达式抓取分析猫眼榜单<em>100</em> 并保存到<em>MongoDB</em>。</p><a id="more"></a><p>【摘要】：最近在学习爬虫，阅读《<a href="https://item.jd.com/12333540.html" target="_blank" rel="noopener">Python 3网络爬虫开发实战</a>》一书，获益匪浅。第一个爬虫实战就是抓取猫眼电影榜单<em>100</em>。</p><p>这里简单介绍下如何分析源代码，通过正则表达式爬取数据并保存到数据库。</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>确保已安装好<em>request</em> 库，<em>pymongo</em> 库，配置好<em>MongoDB</em> 。</p><h4 id="抓取分析"><a href="#抓取分析" class="headerlink" title="抓取分析"></a>抓取分析</h4><p>抓取的目标站点是  <a href="https://maoyan.com/board/4" target="_blank" rel="noopener">https://maoyan.com/board/4</a> ，排名第一的电影是霸王别姬，页面中显示的有效信息有<em>影片名称、主演、上映时间、上映地区、评分、海报</em>等信息。</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/requests%E5%BA%93%E6%8A%93%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8E%92%E8%A1%8C/1.jpg" alt="猫眼电影榜单"></p><p>翻页到第二页，显示的结果是排行<em>11~20</em> 的电影，<em>URL</em> 变成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://maoyan.com/board/4?offset=10</span><br></pre></td></tr></table></figure><p><em>URL</em> 比之前多了一个<em>offset</em> 的参数，继续翻页，显示的结果是排行<em>21~30</em> 的电影，<em>URL</em> 变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://maoyan.com/board/4?offset=20</span><br></pre></td></tr></table></figure><p>总结规律：<em>URL</em> 中参数 <em>offset</em> 代表偏移量值，如果偏移量为<strong><em>n</em></strong> ，则显示的电影序号就是<em>n+1</em> 到<em>n+10</em>, 每页显示<em>10</em> 个。获取 <em>TOP100</em> 电影，则分开请求<em>10</em> 次即可。</p><h4 id="抓取单页面"><a href="#抓取单页面" class="headerlink" title="抓取单页面"></a>抓取单页面</h4><p>首先抓取单个页面信息，定义一个 <strong><em>get_one_page()</em></strong>方法，具体代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">抓取猫眼电影榜单</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_one_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="string">"""获取url的电影信息"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ua = UserAgent()</span><br><span class="line">        headers = &#123;</span><br><span class="line">        <span class="comment"># 引用fake_useragent随机生成一个User-Agent</span></span><br><span class="line">            <span class="string">'User-Agent'</span>: ua.random</span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">except</span> RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="string">"""构造请求"""</span></span><br><span class="line">url = <span class="string">'https://maoyan.com/board/4'</span></span><br><span class="line">html = get_one_page(url)</span><br><span class="line">print(html)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h4 id="正则提取电影信息"><a href="#正则提取电影信息" class="headerlink" title="正则提取电影信息"></a>正则提取电影信息</h4><p>要获取页面影片名称、主演、上映时间、上映地区、评分、海报等信息，分析页面源码，利用<em>Web</em> 开发者工具，查看“网络”-“响应”，获取到<em>response</em> 源代码。</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/requests%E5%BA%93%E6%8A%93%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8E%92%E8%A1%8C/2.jpg" alt="response源码"></p><p>分析其中一个条目，可以看到，一部电影信息对应的源代码是一个<em>dd</em> 节点，我们用正则表达式来提取这里面的一些电影信息。首先，需要提取它的排名信息。排名位于 <em>class</em> 为 <em>board-index</em> 的 <em>i</em> 节点内，正则表达式写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;&lt;dd&gt;.*?board-index-.*?&gt;(.*?)&lt;/i&gt;</span><br></pre></td></tr></table></figure><p>随后提取电影的海报信息，后面有<em>a</em> 节点，其内部有两个<em>img</em> 节点。分别尝试打开两个 <em>img</em> 链接，第二个 <em>img</em> 节点<em>data-src</em> 属性是海报的链接。 提取第二个<em>img</em> 节点的<em>data-src</em> 属性，正则表达式改写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dd&gt;.*?board-index-.*?&gt;(.*?)&lt;/i&gt;.*?data-src=&quot;(.*?)&quot;</span><br></pre></td></tr></table></figure><p>再往后，依次提取电影的名称、主演、发布时间、评分等内容，最终的正则表达式写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dd&gt;.*?board-index-.*?&gt;(.*?)&lt;/i&gt;.*?data-src=&quot;(.*?)&quot;.*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;</span><br></pre></td></tr></table></figure><p>接下来通过调用 <code>findall()</code>方法提取出所有的内容。</p><p>实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one_page</span><span class="params">(html)</span>:</span></span><br><span class="line">    <span class="string">"""解析单页电影信息"""</span></span><br><span class="line">    pattern = re.compile(<span class="string">r'&lt;dd&gt;.*?board-index-.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;'</span>, re.S)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line">    <span class="comment"># 遍历提取结果，去掉提取结果中不必要的信息（主演、上映时间）并生成字典</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">'index'</span>: item[<span class="number">0</span>],</span><br><span class="line">            <span class="string">'image'</span>: item[<span class="number">1</span>],</span><br><span class="line">            <span class="string">'title'</span>: item[<span class="number">2</span>].strip(),            </span><br><span class="line">            <span class="string">'actor'</span>: item[<span class="number">3</span>].strip()[<span class="number">3</span>:] <span class="keyword">if</span> len(item[<span class="number">3</span>]) &gt; <span class="number">3</span> <span class="keyword">else</span> <span class="string">''</span>,</span><br><span class="line">            <span class="string">'time'</span>: item[<span class="number">4</span>].strip()[<span class="number">5</span>:] <span class="keyword">if</span> len(item[<span class="number">4</span>]) &gt; <span class="number">5</span> <span class="keyword">else</span> <span class="string">''</span>,</span><br><span class="line">            <span class="string">'score'</span>: item[<span class="number">5</span>].strip() + item[<span class="number">6</span>].strip()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="写入MongoDB数据"><a href="#写入MongoDB数据" class="headerlink" title="写入MongoDB数据"></a>写入<em>MongoDB</em>数据</h4><p>实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_mongodb</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">"""写入MongoDB数据库"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建数据库需要使用 MongoClient 对象，并且指定连接的 URL 地址和要创建的数据库名。</span></span><br><span class="line">    myclient = pymongo.MongoClient(<span class="string">"mongodb://localhost:27017/"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建数据库test和集合collections，注意使用[]</span></span><br><span class="line">    mydb = myclient[<span class="string">"test"</span>]</span><br><span class="line">    mycol = mydb[<span class="string">"top100"</span>]</span><br><span class="line">    mycol.insert_one(data)</span><br></pre></td></tr></table></figure><h4 id="代码整合"><a href="#代码整合" class="headerlink" title="代码整合"></a>代码整合</h4><p>实现<code>main()</code>方法来调用前面实现的方法，将单页的电影结果写入到数据库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""main()"""</span></span><br><span class="line">    url = <span class="string">'https://maoyan.com/board/4'</span></span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> parse_one_page(html):</span><br><span class="line">        write_to_mongodb(item)</span><br></pre></td></tr></table></figure><h4 id="分页爬取"><a href="#分页爬取" class="headerlink" title="分页爬取"></a>分页爬取</h4><p>因为我们需要抓取的是<em>TOP100</em> 的电影，所以还需要遍历一下，给这个链接传入<em>offset</em> 参数，实现其他<em>90</em> 部电影的爬取，此时添加如下调用即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        main(offset=i*<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>对应的修改下<code>main()</code>函数，接收一个<strong><em>offset</em></strong> 值作为偏移量，然后构造URL 进行爬取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset)</span>:</span></span><br><span class="line">    <span class="string">"""main()"""</span></span><br><span class="line">    url = <span class="string">'https://maoyan.com/board/4?offset='</span>+ str(offset)</span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> parse_one_page(html):</span><br><span class="line">        write_to_mongodb(item)</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>电影榜单<em>TOP100</em> 成功保存到<em>MongoDB</em> 数据库中。</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/requests%E5%BA%93%E6%8A%93%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1%E6%8E%92%E8%A1%8C/3.jpg" alt=""></p><p>完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">抓取猫眼电影排行</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> RequestException</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_one_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="string">"""获取url的电影信息"""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ua = UserAgent()</span><br><span class="line">        headers = &#123;</span><br><span class="line">        <span class="comment"># 引用fake_useragent随机生成一个User-Agent</span></span><br><span class="line">            <span class="string">'User-Agent'</span>: ua.random</span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.text</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">except</span> RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one_page</span><span class="params">(html)</span>:</span></span><br><span class="line">    <span class="string">"""解析单页电影信息"""</span></span><br><span class="line">    pattern = re.compile(<span class="string">r'&lt;dd&gt;.*?board-index-.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;'</span>, re.S)</span><br><span class="line">    items = re.findall(pattern, html)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">'index'</span>: item[<span class="number">0</span>],</span><br><span class="line">            <span class="string">'image'</span>: item[<span class="number">1</span>],</span><br><span class="line">            <span class="string">'title'</span>: item[<span class="number">2</span>].strip(),</span><br><span class="line">            <span class="string">'actor'</span>: item[<span class="number">3</span>].strip()[<span class="number">3</span>:] <span class="keyword">if</span> len(item[<span class="number">3</span>]) &gt; <span class="number">3</span> <span class="keyword">else</span> <span class="string">''</span>,</span><br><span class="line">            <span class="string">'time'</span>: item[<span class="number">4</span>].strip()[<span class="number">5</span>:] <span class="keyword">if</span> len(item[<span class="number">4</span>]) &gt; <span class="number">5</span> <span class="keyword">else</span> <span class="string">''</span>,</span><br><span class="line">            <span class="string">'score'</span>: item[<span class="number">5</span>].strip() + item[<span class="number">6</span>].strip()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_mongodb</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="string">"""写入MongoDB数据库"""</span></span><br><span class="line">    <span class="comment"># 创建数据库需要使用 MongoClient 对象，并且指定连接的 URL 地址和要创建的数据库名。</span></span><br><span class="line">    myclient = pymongo.MongoClient(<span class="string">"mongodb://localhost:27017/"</span>)</span><br><span class="line">    <span class="comment"># 创建数据库test和集合collections，注意使用[]</span></span><br><span class="line">    mydb = myclient[<span class="string">"test"</span>]</span><br><span class="line">    mycol = mydb[<span class="string">"top100"</span>]</span><br><span class="line">    mycol.insert_one(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset)</span>:</span></span><br><span class="line">    <span class="string">"""main()"""</span></span><br><span class="line">    url = <span class="string">'https://maoyan.com/board/4?offset='</span>+ str(offset)</span><br><span class="line">    html = get_one_page(url)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> parse_one_page(html):</span><br><span class="line">        write_to_mongodb(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        main(offset=i*<span class="number">10</span>)</span><br><span class="line">        <span class="comment"># 每请求一次，增加了一个延时等待，防止请求过快</span></span><br><span class="line">        time.sleep(<span class="number">1.5</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过&lt;em&gt;requests&lt;/em&gt;库，正则表达式抓取分析猫眼榜单&lt;em&gt;100&lt;/em&gt; 并保存到&lt;em&gt;MongoDB&lt;/em&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Python爬虫" scheme="https://www.keymou.wang/categories/Python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python爬虫" scheme="https://www.keymou.wang/tags/python%E7%88%AC%E8%99%AB/"/>
    
      <category term="MongoDB" scheme="https://www.keymou.wang/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>tesserocr解析库</title>
    <link href="https://www.keymou.wang/tesserocr%E8%A7%A3%E6%9E%90%E5%BA%93.html"/>
    <id>https://www.keymou.wang/tesserocr解析库.html</id>
    <published>2018-12-21T14:16:44.000Z</published>
    <updated>2019-04-27T04:30:59.867Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>OCR，即Optical Character Recognition，光学字符识别。</p><a id="more"></a><p>是指通过扫描字符，然后通过其形状将其翻译成电子文本的过程。对于图形验证码来说，它们都是一些不规则的字符，这些字符确实是由字符稍加扭曲变换得到的内容。</p><p>tesserocr 是 Python 的一个OCR 识别库，但其实是对 tesseract 做的一层Python API 封装，所以它的核心是 tesseract 。在安装 tesserocr 之前，需要先安装 tesseract。</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><ul><li>tesserocr <a href="https://github.com/sirfz/tesserocr" target="_blank" rel="noopener">GitHub</a></li><li>tesserocr <a href="https://pypi.python.org/pypi/tesserocr" target="_blank" rel="noopener">PyPI</a></li><li>tesseract 下载地址：<a href="https://digi.bib.uni-mannheim.de/tesseract/" target="_blank" rel="noopener">DownLoad</a></li><li>tesseract <a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">GitHub</a></li><li>tesseract <a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">语言包</a></li></ul><h4 id="tesseract"><a href="#tesseract" class="headerlink" title="tesseract"></a>tesseract</h4><p>下载地址：<a href="https://digi.bib.uni-mannheim.de/tesseract/" target="_blank" rel="noopener">点这里</a></p><ul><li>带有 dev 的为开发版本</li><li>带alpha 的为内部测试版本</li><li>带beta 的为公开测试版</li><li>带 rc 的为Release Candidate（候选版本）</li><li>其他为稳定版本，推荐选择 tesseract-3.05 的稳定版本。</li></ul><p>下载完成后双击，可以勾选 Additional language data ( download）选项来安装OCR 识别支持的语言包，这样OCR便可以识别多国语言，然后一路默认，点击 Next 按钮即可。</p><p>不建议勾选Additional language data ( download）选项，因为速度比较慢，可以安装后直接下载语言包，然后将语言包复制到安装目录的 tessdata 目录下即可。</p><h4 id="tesserocr"><a href="#tesserocr" class="headerlink" title="tesserocr"></a>tesserocr</h4><p>使用命令：</p><p><code>pip install tesserocr pillow</code></p><p>若安装报错，提示信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: Microsoft Visual C++ 14.0 is required. Get it with &quot;Microsoft Visual C++ Build Tools&quot;: https://visualstudio.microsoft.com/downloads/</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>下载对应版本的whl 包（和下载的tesseract 版本对应），<a href="https://github.com/simonflueckiger/tesserocr-windows_build/releases" target="_blank" rel="noopener">地址</a>，然后使用命令行安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install &lt;package_name&gt;.whl</span><br></pre></td></tr></table></figure><h4 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h4><p>以如下面所示的图片为样例进行测试。</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/tesserocr%E8%A7%A3%E6%9E%90%E5%BA%93/1.jpg" alt="测试图片"></p><p>首先使用命令行进行测试，使用 tesseract 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Keymou\Desktop</span><br><span class="line">λ tesseract image.png result -l eng &amp;&amp; cat result.txt</span><br><span class="line">Tesseract Open Source OCR Engine v3.05.02 with Leptonica</span><br><span class="line">Python3WebSpider</span><br></pre></td></tr></table></figure><p>其中第一个参数为图片名称，第二个参数result 为结果保存的目标文件名称，-l  指定使用的语言包，在此使用英文（ eng ）。然后，再用cat 命令将结果输出。</p><p>运行结果便是图片的识别结果：Python3WebSpider。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract imagename|stdin outputbase|stdout [options...] [configfile...]</span><br></pre></td></tr></table></figure><p>用Python 代码来测试，借助于 tesserocr 库。</p><p>测试代码 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tesserocr</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">image = Image.open(<span class="string">r'D:\\python\\image.png'</span>)</span><br><span class="line">print(tesserocr.image_to_text(image))</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p>Python3WebSpider</p><p>或者 直接在 cmd 中 直接调用 file_to_text()方法，代码过程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">λ python</span><br><span class="line">Python 3.7.0 (default, Jun 28 2018, 08:04:48) [MSC v.1912 64 bit (AMD64)] :: Anaconda, Inc. on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import tesserocr</span><br><span class="line">&gt;&gt;&gt; print(tesserocr.file_to_text(&apos;image.png&apos;))</span><br><span class="line">Python3WebSpider</span><br></pre></td></tr></table></figure><p>推荐一个颜值很高的 cmd 工具，Cmder。</p><p><img src="https://github.com/keymou/blog_images/raw/master/content/tesserocr%E8%A7%A3%E6%9E%90%E5%BA%93/2.jpg" alt="Cmder"></p><p>如果成功输出结果，则证明 tesseract 和 tesserocr 都已经安装成功。</p><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><p>安装 tesserocr 折腾了很久，安装过程或许会碰到意外情况，不要慌，首先上网搜索看看，是否能解决，根据实际情况排查解决问题。</p><p>常见报错信息： <code>RuntimeError: Failed to init API, possibly an invalid tessdata path: D:\ProgramData\Anaconda3\</code></p><p>分析错误信息，是初始化API 失败，可能是一个无效的tessdata 路径。检查下后面给出path 下是否有 tessdata 目录。</p><ol><li>第一种情况，没有该目录，则需要新建目录，然后将 tesseract 安装目录下的tessdata 复制该path 下。若提示的path 存在并且已经有tessdata 目录，就需要检查下是否环境变量没有配置。新增环境变量 TESSDATA_PREFIX，变量值为 指向 tessdata 的路径，如 C:\Tesseract-OCR\tessdata</li><li>第二种情况，path目录下存在 tessdata，环境变量也已生效，但python 代码测试时仍报 API 初始化错误，可能需要考虑是否版本问题。我折腾了很久，安装的 tesseract 4.0，但一直报错，换成tesseract-3.05，问题解决。</li></ol><p>python3 通过Anaconda3 安装的，可以通过以下命令试安装：</p><p><code>&gt; conda install -c simonflueckiger tesserocr</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OCR，即Optical Character Recognition，光学字符识别。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.keymou.wang/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="tesserocr" scheme="https://www.keymou.wang/tags/tesserocr/"/>
    
      <category term="python爬虫" scheme="https://www.keymou.wang/tags/python%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>软件开发生命周期</title>
    <link href="https://www.keymou.wang/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"/>
    <id>https://www.keymou.wang/软件开发生命周期.html</id>
    <published>2018-12-18T08:17:32.000Z</published>
    <updated>2019-04-27T04:05:38.749Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算机行业流行一个笑话：有三样东西在制造过程中是永远看不见的——法律、香肠和软件。</p><a id="more"></a> <p>这种说法不完全对，但有些软件开发严格有序，有些软件控制却混乱不堪。软件产品从最初构思到公开发行的过程称为<em>软件开发生命周期模式。</em></p><p>以下是常用的模式：</p><ol><li><p><strong>大爆炸模式</strong></p><p>最简单的软件开发模式，优点是简单。计划、进度安排和正规开发过程几乎没有，所有精力花费在开发软件和编写代码上。</p></li><li><p><strong>编写边改模式</strong></p><p>通常只有粗略的想法，进行一些简单的设计，然后开始漫长的来回编写、测试和修改缺陷的过程，反复直到觉得足够了，就发布产品。</p></li><li><p><strong>瀑布模式</strong></p><p><img src="https://github.com/keymou/blog_images/raw/master/content/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/1.jpg" alt="瀑布模式"></p><p>最典型的预见性的方法，严格遵循预先计划的需求分析、设计、编码、集成、测试、维护的步骤顺序进行。<br>步骤成果作为衡量进度的方法，例如需求规格，设计文档，测试计划和代码审阅等等。 </p><p>瀑布式的主要的问题是它的严格分级导致的自由度降低，项目早期即作出承诺导致对后期需求的变化难以调整，代价高昂。瀑布式方法在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。  </p></li><li><p><strong>螺旋模式</strong></p><p>核心就在于不需要在刚开始的时候就把所有事情都定义的清清楚楚。轻松上阵，定义最重要的功能，实现它，然后听取客户的意见，之后再进入到下一个阶段。</p><p>螺旋模式每一次循环包括6个步骤：</p><p>1）明确目标、可选方案和限制条件。</p><p>2）明确并化解风险。</p><p>3）评估可选方案。</p><p>4）当前阶段的开发和测试。</p><p>5）计划下一阶段。</p><p>6）确定进入下一阶段的方法。</p><p>螺旋模型很大程度上是一种风险驱动的方法体系，因为在每个阶段之前及经常发生的循环之前，都必须首先进行风险评估。</p></li><li><p><strong>迭代式开发</strong></p><p>也被称作<strong>迭代增量式开发</strong>或<strong>迭代进化式开发</strong>，是一种与传统的瀑布式开发相反的软件开发过程，它弥补了传统开发方式中的一些弱点，具有更高的成功率和生产率。</p><p>每次只设计和实现这个产品的一部分，逐步逐步完成的方法叫迭代开发，每次设计和实现一个阶段叫做一个迭代。</p><p>在迭代开发方法中，每一次迭代都包括了需求分析、设计、实现与测试。采用这种方法，开发工作可以在需求被完整地确定之前启动，并在一次迭代中完成系统的一部分功能或业务逻辑的开发工作。再通过客户的反馈来细化需求，并开始新一轮的迭代。</p><p>迭代式开发的优点：<br>　　1、降低风险<br>　　2、得到早期用户反馈<br>　　3、持续的测试和集成<br>　　4、使用变更<br>　　5、提高复用性</p></li></ol><p>   <strong>敏捷软件开发</strong></p><p>   又称<strong>敏捷开发</strong>，是一种应对快速变化的需求的一种软件开发能力。更强调程序员团队与业务专家之间的紧密协作、面对面的沟通、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发中人的作用。</p><p>   敏捷开发的目的：</p><blockquote><p>通过过程和工具理解个人和交流的作用</p><p>通过全面的文档理解运行的软件</p><p>通过合同和谈判得到客户的协作</p><p>在计划的执行中做出对变更的响应</p></blockquote><p>   迭代开发是<strong>一种</strong>软件开发的<strong>生命周期模型</strong>，敏捷开发是多种软件开发项目管理方法的集合，其中包括了XP、Scrum等，简单来说，<strong>迭代式开发模型是敏捷开发普遍使用的软件生命周期模型</strong>，<strong>敏捷开发所包含的内容比迭代模型宽泛的多</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机行业流行一个笑话：有三样东西在制造过程中是永远看不见的——法律、香肠和软件。&lt;/p&gt;
    
    </summary>
    
      <category term="软件开发" scheme="https://www.keymou.wang/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="软件开发" scheme="https://www.keymou.wang/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>アンナチュラル</title>
    <link href="https://www.keymou.wang/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB.html"/>
    <id>https://www.keymou.wang/アンナチュラル.html</id>
    <published>2018-12-16T02:20:38.000Z</published>
    <updated>2019-04-27T03:14:42.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>又是一个周末啦，安利一部日剧《アンナチュラル》非自然死亡 ，绝对好看到爆。。。</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=560738533&auto=1&height=66"></iframe>  <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>三澄美琴（石原里美 饰）是在民间法医组织“UDI”工作的女法医，该组织专门接收由于非正常原因导致死亡的遗体，对其进行解剖以求找到案件的真相。和美琴一起工作的，还有法医中堂系（井浦新 饰）、记录员九部六郎（洼田正孝 饰）和检查技师东海林夕子（市川实日子 饰）等人。 中堂系虽然拥有着丰富的临床经验，个性却乖僻古怪，对正义和法律理解不同的美琴和中堂之间，常常产生无法调和的矛盾。其实，中堂有一个无人知晓的秘密，他的女友在一场“意外”中不幸丧生，可种种蛛丝马迹向中堂揭示了，是一名连环杀人犯取走了女友的性命。中堂不畏人言坚定的留在UDI，正是为了找到杀死女友的凶手。  </p><p>剧情我就不剧透了，优酷、芒果有资源。  </p><p><a href="https://list.youku.com/show/id_zefbfbd3e4cefbfbd03ef.html?spm=a2h0j.11185381.bpmodule-playpage-lefttitle.5~5~H1~8~A" target="_blank" rel="noopener">优酷</a> | <a href="https://www.mgtv.com/h/321935.html?fpa=se" target="_blank" rel="noopener">芒果TV</a>  </p><h4 id="经典台词"><a href="#经典台词" class="headerlink" title="经典台词"></a>经典台词</h4><font face="黑体" color="#FFB6C1"><center>伴侣就要找那种睡相让你觉得很喜欢的人</center></font>  <p><img src="https://github.com/keymou/blog_images/raw/master/content/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/1.jpg" alt="01-我也想和连睡相都喜欢的人在一起"></p><font face="黑体" color="#FFB6C1"><center>男女关系中是不会只有一方有错的</center></font>  <p><img src="https://github.com/keymou/blog_images/raw/master/content/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/2.jpg" alt="02-男女关系">  </p><font face="黑体" color="#FFB6C1"><center>有工夫绝望的话 还不如吃点好吃的去睡觉呢</center></font>  <p><img src="https://github.com/keymou/blog_images/raw/master/content/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/3.jpg" alt="03-处世态度">  </p><font face="黑体" color="#FFB6C1"><center>只是把孩子当作自己的所有物，不明白孩子跟自己是互相独立的个体</center></font>  <p><img src="https://github.com/keymou/blog_images/raw/master/content/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/4.jpg" alt="04-对待孩子">  </p><font face="黑体" color="#FFB6C1"><center>对女性的歧视</center></font><br><img src="https://github.com/keymou/blog_images/raw/master/content/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/5.jpg" alt="05-女性歧视"><br><br><img src="https://github.com/keymou/blog_images/raw/master/content/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/6.jpg" alt="06"><br><br><font face="黑体" color="#FFB6C1"><center>人这种生物 不管是谁<br>切开来剥皮后都只是一团肉而已<br>死了就明白了</center></font>  <p><img src="https://github.com/keymou/blog_images/raw/master/content/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/7.jpg" alt="07-终生平等">  </p><font face="黑体" color="#CD5C5C"><center>特别认同中堂这段话，人生不就是这样嘛</center></font>  <p><img src="https://github.com/keymou/blog_images/raw/master/content/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/8.jpg" alt="08-关于梦想">  </p><font face="黑体" color="#FFB6C1"><center>为了活下去</center></font>  <p><img src="https://github.com/keymou/blog_images/raw/master/content/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/9.jpg" alt="09"><br> <font face="黑体" color="#FF00FF"><center>梦想什么的<br>也没必要说得那么夸张<br>有个目标就行<br></center></font>  </p><p><img src="https://github.com/keymou/blog_images/raw/master/content/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/10.jpg" alt="10-I have a dream">  </p><p><img src="https://github.com/keymou/blog_images/raw/master/content/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/11.jpg" alt="11-工作的意义">  </p><font face="黑体" color="#FFB6C1"><center>每个人都是罪人 为了赎罪而工作</center></font>  <p><img src="https://github.com/keymou/blog_images/raw/master/content/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/12.jpg" alt="12">  </p><font face="黑体" color="#FF4500"><center><br>不管女性穿什么样的衣服<br>或者喝得酩酊大醉<br>都不能成为肆意妄为的理由<br>没有得到双方一致同意的性行为就是犯罪<br></center></font>    <p><img src="https://github.com/keymou/blog_images/raw/master/content/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/13.jpg" alt="13">  </p><font face="黑体" color="#FFB6C1"><center>欺凌杀人</center></font>  <p><img src="https://github.com/keymou/blog_images/raw/master/content/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/14.jpg" alt="14">  </p><font face="黑体"><center>你就算献出了自己的生命<br>你的痛楚<br>肯定也无法传达给他们<br>你的人生 &nbsp;属于你自己</center></font>  <p><img src="https://github.com/keymou/blog_images/raw/master/content/%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB/15.jpg" alt="15">  </p><font face="黑体" color="#008000"><center>看官点个赞再走吧</center></font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是一个周末啦，安利一部日剧《アンナチュラル》非自然死亡 ，绝对好看到爆。。。&lt;/p&gt;
    
    </summary>
    
      <category term="日剧" scheme="https://www.keymou.wang/categories/%E6%97%A5%E5%89%A7/"/>
    
    
      <category term="石原里美" scheme="https://www.keymou.wang/tags/%E7%9F%B3%E5%8E%9F%E9%87%8C%E7%BE%8E/"/>
    
      <category term="日剧" scheme="https://www.keymou.wang/tags/%E6%97%A5%E5%89%A7/"/>
    
      <category term="Unnatural" scheme="https://www.keymou.wang/tags/Unnatural/"/>
    
  </entry>
  
  <entry>
    <title>python常见知识点</title>
    <link href="https://www.keymou.wang/python%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html"/>
    <id>https://www.keymou.wang/python常见知识点.html</id>
    <published>2018-12-14T10:23:08.000Z</published>
    <updated>2019-04-27T04:29:34.992Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在学习python，总结了下python常用的知识点。</p><a id="more"></a><h4 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">fun(a)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(b)</span>:</span></span><br><span class="line">    b.append(<span class="number">1</span>)</span><br><span class="line">fun(b)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>所有的变量都可以理解是内存中一个对象的“引用”。类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。<br>在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。</p><h4 id="实例方法、类方法、静态方法"><a href="#实例方法、类方法、静态方法" class="headerlink" title="实例方法、类方法、静态方法"></a>实例方法、类方法、静态方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(<span class="string">"executing foo(%s)"</span>%(x))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        print(<span class="string">"executing foo(%s,%s)"</span>%(self,x))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls,x)</span>:</span></span><br><span class="line">        print(<span class="string">"executing class_foo(%s,%s)"</span>%(cls,x))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(<span class="string">"executing static_foo(%s)"</span>%x)</span><br><span class="line"></span><br><span class="line">a=A()</span><br><span class="line">a.foo(<span class="number">2</span>)</span><br><span class="line">a.class_foo(<span class="number">2</span>)</span><br><span class="line">a.static_foo(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>先理解下函数参数里面的<code>self</code>和<code>cls</code>。这个<code>self</code>和<code>cls</code>是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.<br>对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>).<br>类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)</code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.</p><p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p><table><thead><tr><th>\</th><th>实例方法</th><th>类方法</th><th>静态方法</th></tr></thead><tbody><tr><td><code>a = A()</code></td><td><code>a.foo(x)</code></td><td><code>a.class_foo(x)</code></td><td><code>a.static_foo(x)</code></td></tr><tr><td><code>A</code></td><td>不可用</td><td><code>A.class_foo(x)</code></td><td><code>A.static_foo(x)</code></td></tr></tbody></table><h4 id="类变量、实例变量"><a href="#类变量、实例变量" class="headerlink" title="类变量、实例变量"></a>类变量、实例变量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=<span class="string">"aaa"</span></span><br><span class="line"> </span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=<span class="string">"bbb"</span></span><br><span class="line">print(p1.name)  <span class="comment"># bbb</span></span><br><span class="line">print(p2.name)  <span class="comment"># aaa</span></span><br><span class="line">print(Person.name)  <span class="comment"># aaa</span></span><br></pre></td></tr></table></figure><p>类变量就是供类使用的变量,实例变量就是供实例使用的。</p><h4 id="Python自省"><a href="#Python自省" class="headerlink" title="Python自省"></a>Python自省</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="string">'Hello'</span></span><br><span class="line">print(type(a), type(b))</span><br></pre></td></tr></table></figure><ul><li>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型。<br>比如type()、dir()、getattr()、hasattr()、isinstance()</li></ul><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">multiples = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> <span class="keyword">is</span> <span class="number">0</span>]</span><br><span class="line">print(multiples)</span><br><span class="line"></span><br><span class="line">mcase = &#123;<span class="string">'a'</span>: <span class="number">10</span>, <span class="string">'b'</span>: <span class="number">34</span>, <span class="string">'A'</span>: <span class="number">7</span>, <span class="string">'Z'</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">mcase_frequency = &#123;</span><br><span class="line">    k.lower(): mcase.get(k.lower(), <span class="number">0</span>) + mcase.get(k.upper(), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> mcase.keys()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(mcase_frequency)</span><br><span class="line"><span class="comment"># mcase_frequency == &#123;'a': 17, 'z': 3, 'b': 34&#125;</span></span><br></pre></td></tr></table></figure><ul><li>列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。规范:<code>variable = [out_exp for out_exp in input_list if out_exp == 2]</code></li><li>字典推导式，上述例子把同一个字母但不同大小写的值合并起来。<br>可以快速对换一个字典的键和值：<br><code>{v: k for k, v in dict.items()}</code></li></ul><h4 id="单下划线和双下划线"><a href="#单下划线和双下划线" class="headerlink" title="单下划线和双下划线"></a>单下划线和双下划线</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__superprivate = <span class="string">'Hello'</span></span><br><span class="line">        self._semiprivate = <span class="string">', world'</span></span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line">print(mc._semiprivate)</span><br><span class="line">print(mc.__dict__)</span><br><span class="line"><span class="comment"># print(mc.__superprivate)</span></span><br><span class="line"><span class="comment"># AttributeError: 'MyClass' object has no attribute '__superprivate'</span></span><br></pre></td></tr></table></figure><ul><li><code>__foo__</code>：一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突.</li><li><code>_foo</code>：一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.</li><li><code>__foo</code>：这个有真正的意义:解析器用_classname__foo来代替这个名字,以区别和其他类相同的命名.</li></ul><h4 id="字符串格式化：-和-format的区别"><a href="#字符串格式化：-和-format的区别" class="headerlink" title="字符串格式化：%和.format的区别"></a>字符串格式化：%和.format的区别</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'Joe'</span></span><br><span class="line">print(<span class="string">'Name is %s'</span> %name)</span><br><span class="line">print(<span class="string">'Name is &#123;&#125;'</span>.format(name))</span><br><span class="line">name = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># print('Name is %s' %name)  # TypeError: not all arguments converted during string formatting</span></span><br><span class="line">print(<span class="string">'Name is &#123;&#125;'</span>.format(name))</span><br><span class="line">print(<span class="string">'Name is %s'</span> %(name,))</span><br></pre></td></tr></table></figure><p><code>format</code>简洁，<code>%</code>无法同时传递一个变量和元组</p><h4 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mylist is an iterable</span></span><br><span class="line"><span class="comment"># These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># yield is a keyword that is used like return, except the function will return a generator.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createGenerator</span><span class="params">()</span>:</span></span><br><span class="line">    mylist = range(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line">        <span class="keyword">yield</span> i*i</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a generator</span></span><br><span class="line">mygenerator = createGenerator()</span><br><span class="line">print(mygenerator)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'****'</span>)</span><br><span class="line"><span class="comment"># To master yield, you must understand that when you call the function, the code you have written in the function body does not run.</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> mygenerator:</span><br><span class="line">    print(j)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Generators are iterators, a kind of iterable you can only iterate over once. Generators do not store all the values in memory, they generate the values on the fly.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="args-and-kwargs”"><a href="#args-and-kwargs”" class="headerlink" title="*args and **kwargs”"></a>*args and **kwargs”</h4><p>不确定你的函数里将要传递多少参数时你可以用<code>*args</code>。例如，它可以传递任意数量的参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_everything</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> count, thing <span class="keyword">in</span> enumerate(args):</span><br><span class="line">        print(<span class="string">'&#123;0&#125;. &#123;1&#125;'</span>.format(count, thing))</span><br><span class="line"></span><br><span class="line">print_everything(<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'cabbage'</span>)</span><br></pre></td></tr></table></figure></p><p><code>**kwargs</code>允许你使用没有事先定义的参数名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">table_things</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        print(<span class="string">'&#123;0&#125;=&#123;1&#125;'</span>.format(name, value))</span><br><span class="line"></span><br><span class="line">table_things(apple = <span class="string">'fruit'</span>, cabbage = <span class="string">'vegetable'</span>)</span><br></pre></td></tr></table></figure><p>也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给<code>*args</code>和<code>**kwargs</code>。命名参数在列表的最前端，<code>*args</code>和<code>**kwargs</code>可以同时在函数的定义中，但是<code>*args</code>必须在<code>**kwargs</code>前面.</p><h4 id="面向切面编程AOP和装饰器"><a href="#面向切面编程AOP和装饰器" class="headerlink" title="面向切面编程AOP和装饰器"></a>面向切面编程AOP和装饰器</h4><ul><li>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。</li><li><p>装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。<br><strong>概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makebold</span><span class="params">(fn)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"&lt;b&gt;"</span> + fn() + <span class="string">"&lt;/b&gt;"</span></span><br><span class="line">   <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span><span class="params">(fn)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">()</span>:</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"&lt;i&gt;"</span> + fn() + <span class="string">"&lt;/i&gt;"</span></span><br><span class="line">   <span class="keyword">return</span> wrapped</span><br></pre></td></tr></table></figure></li><li><p>装饰器的作用就是为已经存在的对象添加额外的功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@makebold</span></span><br><span class="line"><span class="meta">@makeitalic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line">print(hello())</span><br></pre></td></tr></table></figure></li></ul><h4 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h4><p>当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为<em>鸭子</em>。<br>并不关心对象是什么类型，到底是不是鸭子，只关心行为。<br>在python中，有很多file-like的东西，比如<code>StringIO</code>,<code>GzipFile</code>,<code>socket</code>。它们有很多相同的方法，我们把它们当作文件使用。</p><h4 id="Python中函数重载"><a href="#Python中函数重载" class="headerlink" title="Python中函数重载"></a>Python中函数重载</h4><ul><li>函数重载主要是为了解决两个问题:可变参数类型、可变参数个数。</li><li>一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载。<br>情况1：函数功能相同，但是参数类型不同，根本不需要处理，因为python可以接受任何类型的参数<br>情况2：函数功能相同，但参数个数不同，答案就是缺省参数。<br><strong>python 自然就不需要函数重载。</strong></li></ul><h4 id="new和init的区别"><a href="#new和init的区别" class="headerlink" title="new和init的区别"></a><strong>new</strong>和<strong>init</strong>的区别</h4><ul><li><code>__new__</code>是一个静态方法,而<code>__init__</code>是一个实例方法.</li><li><code>__new__</code>方法会返回一个创建的实例,而<code>__init__</code>什么都不返回.</li><li>只有在<code>__new__</code>返回一个<code>cls</code>的实例时后面的<code>__init__</code>才能被调用.</li><li>当创建一个新实例时调用<code>__new__</code>,初始化一个实例时用<code>__init__</code>.</li></ul><p>ps: <strong>metaclass</strong>是创建类时起作用.所以我们可以分别使用<strong>metaclass</strong>,<strong>new</strong>和<strong>init</strong>来分别在类创建,实例创建和实例初始化的时候做一些小手脚.</p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><h5 id="使用new方法"><a href="#使用new方法" class="headerlink" title="使用new方法"></a>使用<strong>new</strong>方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="共享属性-创建实例时把所有实例的-dict-指向同一个字典-这样它们具有相同的属性和方法"><a href="#共享属性-创建实例时把所有实例的-dict-指向同一个字典-这样它们具有相同的属性和方法" class="headerlink" title="共享属性 创建实例时把所有实例的__dict__指向同一个字典,这样它们具有相同的属性和方法."></a>共享属性 创建实例时把所有实例的<code>__dict__</code>指向同一个字典,这样它们具有相同的属性和方法.</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Borg</span><span class="params">(object)</span>:</span></span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        <span class="keyword">return</span> ob</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span><span class="params">(Borg)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="装饰器版本"><a href="#装饰器版本" class="headerlink" title="装饰器版本"></a>装饰器版本</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> getinstance</span><br><span class="line"> </span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h5 id="import方法"><a href="#import方法" class="headerlink" title="import方法"></a>import方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysingleton.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">my_singleton = My_Singleton()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># to use</span></span><br><span class="line"><span class="comment"># from mysingleton import my_singleton</span></span><br><span class="line"><span class="comment"># my_singleton.foo()</span></span><br></pre></td></tr></table></figure><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul><li>一个变量的作用域总是由在代码中被赋值的地方所决定的。</li><li>当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：</li><li>本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）</li></ul><h4 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h4><p>闭包(closure)是函数式编程的重要的语法结构<br>创建一个闭包必须满足以下几点:</p><ul><li>必须有一个内嵌函数</li><li>内嵌函数必须引用外部函数中的变量</li><li>外部函数的返回值必须是内嵌函数</li></ul><h4 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h4><p>lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map( <span class="keyword">lambda</span> x: x*x, [y <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">10</span>)] )</span><br></pre></td></tr></table></figure></p><h4 id="Python里的拷贝"><a href="#Python里的拷贝" class="headerlink" title="Python里的拷贝"></a>Python里的拷贝</h4><ul><li>copy浅拷贝，没有拷贝子对象，所以原始数据改变，子对象会改变</li><li>深拷贝，包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]  <span class="comment">#原始对象</span></span><br><span class="line"> </span><br><span class="line">b = a  <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)  <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)  <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"> </span><br><span class="line">a.append(<span class="number">5</span>)  <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">'c'</span>)  <span class="comment">#修改对象a中的['a', 'b']数组对象</span></span><br><span class="line"> </span><br><span class="line">print(<span class="string">'a = '</span>, a)</span><br><span class="line">print(<span class="string">'b = '</span>, b)</span><br><span class="line">print(<span class="string">'c = '</span>, c)</span><br><span class="line">print(<span class="string">'d = '</span>, d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># a =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]</span></span><br><span class="line"><span class="comment"># b =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]</span></span><br><span class="line"><span class="comment"># c =  [1, 2, 3, 4, ['a', 'b', 'c']]</span></span><br><span class="line"><span class="comment"># d =  [1, 2, 3, 4, ['a', 'b']]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Python垃圾回收机制"><a href="#Python垃圾回收机制" class="headerlink" title="Python垃圾回收机制"></a>Python垃圾回收机制</h4><p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。<br>在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p><ol><li>引用计数<br>PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。</li><li>标记-清除机制<br>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</li><li>分代技术<br>整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</li></ol><h4 id="Python的is"><a href="#Python的is" class="headerlink" title="Python的is"></a>Python的is</h4><p><code>is</code>是对比地址，<code>==</code>是对比值</p><h4 id="read，readline和readlines"><a href="#read，readline和readlines" class="headerlink" title="read，readline和readlines"></a>read，readline和readlines</h4><ul><li><code>read</code> 读取整个文件</li><li><code>readline</code> 读取下一行,使用生成器方法</li><li><code>readlines</code> 读取整个文件到一个迭代器以供我们遍历</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习python，总结了下python常用的知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.keymou.wang/categories/python/"/>
    
    
      <category term="python" scheme="https://www.keymou.wang/tags/python/"/>
    
  </entry>
  
</feed>
