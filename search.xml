<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[软件开发生命周期]]></title>
    <url>%2F2018%2F12%2F18%2F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[计算机行业流行一个笑话：有三样东西在制造过程中是永远看不见的——法律、香肠和软件。 这种说法不完全对，但有些软件开发严格有序，有些软件控制却混乱不堪。软件产品从最初构思到公开发行的过程称为软件开发生命周期模式。 以下是常用的模式： 大爆炸模式 最简单的软件开发模式，优点是简单。计划、进度安排和正规开发过程几乎没有，所有精力花费在开发软件和编写代码上。 编写边改模式 通常只有粗略的想法，进行一些简单的设计，然后开始漫长的来回编写、测试和修改缺陷的过程，反复直到觉得足够了，就发布产品。 瀑布模式 最典型的预见性的方法，严格遵循预先计划的需求分析、设计、编码、集成、测试、维护的步骤顺序进行。步骤成果作为衡量进度的方法，例如需求规格，设计文档，测试计划和代码审阅等等。 瀑布式的主要的问题是它的严格分级导致的自由度降低，项目早期即作出承诺导致对后期需求的变化难以调整，代价高昂。瀑布式方法在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。 螺旋模式 核心就在于不需要在刚开始的时候就把所有事情都定义的清清楚楚。轻松上阵，定义最重要的功能，实现它，然后听取客户的意见，之后再进入到下一个阶段。 螺旋模式每一次循环包括6个步骤： 1）明确目标、可选方案和限制条件。 2）明确并化解风险。 3）评估可选方案。 4）当前阶段的开发和测试。 5）计划下一阶段。 6）确定进入下一阶段的方法。 螺旋模型很大程度上是一种风险驱动的方法体系，因为在每个阶段之前及经常发生的循环之前，都必须首先进行风险评估。 迭代式开发 也被称作迭代增量式开发或迭代进化式开发，是一种与传统的瀑布式开发相反的软件开发过程，它弥补了传统开发方式中的一些弱点，具有更高的成功率和生产率。 每次只设计和实现这个产品的一部分，逐步逐步完成的方法叫迭代开发，每次设计和实现一个阶段叫做一个迭代。 在迭代开发方法中，每一次迭代都包括了需求分析、设计、实现与测试。采用这种方法，开发工作可以在需求被完整地确定之前启动，并在一次迭代中完成系统的一部分功能或业务逻辑的开发工作。再通过客户的反馈来细化需求，并开始新一轮的迭代。 迭代式开发的优点： 1、降低风险 2、得到早期用户反馈 3、持续的测试和集成 4、使用变更 5、提高复用性 敏捷软件开发 又称敏捷开发，是一种应对快速变化的需求的一种软件开发能力。更强调程序员团队与业务专家之间的紧密协作、面对面的沟通、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发中人的作用。 敏捷开发的目的： 通过过程和工具理解个人和交流的作用 通过全面的文档理解运行的软件 通过合同和谈判得到客户的协作 在计划的执行中做出对变更的响应 迭代开发是一种软件开发的生命周期模型，敏捷开发是多种软件开发项目管理方法的集合，其中包括了XP、Scrum等，简单来说，迭代式开发模型是敏捷开发普遍使用的软件生命周期模型，敏捷开发所包含的内容比迭代模型宽泛的多。]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>软件开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[アンナチュラル]]></title>
    <url>%2F2018%2F12%2F16%2F%E3%82%A2%E3%83%B3%E3%83%8A%E3%83%81%E3%83%A5%E3%83%A9%E3%83%AB%2F</url>
    <content type="text"><![CDATA[又是一个周末啦，安利一部日剧《アンナチュラル》非自然死亡 简介三澄美琴（石原里美 饰）是在民间法医组织“UDI”工作的女法医，该组织专门接收由于非正常原因导致死亡的遗体，对其进行解剖以求找到案件的真相。和美琴一起工作的，还有法医中堂系（井浦新 饰）、记录员九部六郎（洼田正孝 饰）和检查技师东海林夕子（市川实日子 饰）等人。 中堂系虽然拥有着丰富的临床经验，个性却乖僻古怪，对正义和法律理解不同的美琴和中堂之间，常常产生无法调和的矛盾。其实，中堂有一个无人知晓的秘密，他的女友在一场“意外”中不幸丧生，可种种蛛丝马迹向中堂揭示了，是一名连环杀人犯取走了女友的性命。中堂不畏人言坚定的留在UDI，正是为了找到杀死女友的凶手。 剧情我就不剧透了，优酷、芒果有资源。 优酷 | 芒果TV 经典台词伴侣就要找那种睡相让你觉得很喜欢的人男女关系中是不会只有一方有错的有工夫绝望的话 还不如吃点好吃的去睡觉呢只是把孩子当作自己的所有物，不明白孩子跟自己是互相独立的个体对女性的歧视人这种生物 不管是谁切开来剥皮后都只是一团肉而已死了就明白了 特别认同中堂这段话，人生不就是这样嘛 为了活下去 梦想什么的也没必要说得那么夸张有个目标就行 每个人都是罪人 为了赎罪而工作 不管女性穿什么样的衣服或者喝得酩酊大醉都不能成为肆意妄为的理由没有得到双方一致同意的性行为就是犯罪 欺凌杀人 你就算献出了自己的生命你的痛楚肯定也无法传达给他们你的人生 &nbsp;属于你自己 看官点个赞再走吧]]></content>
      <categories>
        <category>日剧</category>
      </categories>
      <tags>
        <tag>石原里美,日剧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python常见知识点]]></title>
    <url>%2F2018%2F12%2F14%2Fpython%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[最近在学习python，总结了下python常用的知识点。 函数参数传递1234567891011a = 1def fun(a): a = 2fun(a)print(a)b = []def fun(b): b.append(1)fun(b)print(b) 所有的变量都可以理解是内存中一个对象的“引用”。类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。 实例方法、类方法、静态方法12345678910111213141516171819def foo(x): print(&quot;executing foo(%s)&quot;%(x))class A(object): def foo(self,x): print(&quot;executing foo(%s,%s)&quot;%(self,x)) @classmethod def class_foo(cls,x): print(&quot;executing class_foo(%s,%s)&quot;%(cls,x)) @staticmethod def static_foo(x): print(&quot;executing static_foo(%s)&quot;%x)a=A()a.foo(2)a.class_foo(2)a.static_foo(2) 先理解下函数参数里面的self和cls。这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用foo(x),这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是foo(self, x),为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的a.foo(x)(其实是foo(a, x)).类方法一样,只不过它传递的是类而不是实例,A.class_foo(x).注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好. 对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用a.static_foo(x)或者A.static_foo(x)来调用. \ 实例方法 类方法 静态方法 a = A() a.foo(x) a.class_foo(x) a.static_foo(x) A 不可用 A.class_foo(x) A.static_foo(x) 类变量、实例变量123456789class Person: name=&quot;aaa&quot; p1=Person()p2=Person()p1.name=&quot;bbb&quot;print(p1.name) # bbbprint(p2.name) # aaaprint(Person.name) # aaa 类变量就是供类使用的变量,实例变量就是供实例使用的。 Python自省123a = 1b = &apos;Hello&apos;print(type(a), type(b)) 自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型。比如type()、dir()、getattr()、hasattr()、isinstance() 列表推导式123456789101112multiples = [i for i in range(30) if i % 3 is 0]print(multiples)mcase = &#123;&apos;a&apos;: 10, &apos;b&apos;: 34, &apos;A&apos;: 7, &apos;Z&apos;: 3&#125;mcase_frequency = &#123; k.lower(): mcase.get(k.lower(), 0) + mcase.get(k.upper(), 0) for k in mcase.keys()&#125;print(mcase_frequency)# mcase_frequency == &#123;&apos;a&apos;: 17, &apos;z&apos;: 3, &apos;b&apos;: 34&#125; 列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。规范:variable = [out_exp for out_exp in input_list if out_exp == 2] 字典推导式，上述例子把同一个字母但不同大小写的值合并起来。可以快速对换一个字典的键和值：{v: k for k, v in dict.items()} 单下划线和双下划线12345678910class MyClass(): def __init__(self): self.__superprivate = &apos;Hello&apos; self._semiprivate = &apos;, world&apos;mc = MyClass()print(mc._semiprivate)print(mc.__dict__)# print(mc.__superprivate)# AttributeError: &apos;MyClass&apos; object has no attribute &apos;__superprivate&apos; __foo__：一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突. _foo：一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式. __foo：这个有真正的意义:解析器用_classname__foo来代替这个名字,以区别和其他类相同的命名. 字符串格式化：%和.format的区别1234567name = &apos;Joe&apos;print(&apos;Name is %s&apos; %name)print(&apos;Name is &#123;&#125;&apos;.format(name))name = (1, 2, 3)# print(&apos;Name is %s&apos; %name) # TypeError: not all arguments converted during string formattingprint(&apos;Name is &#123;&#125;&apos;.format(name))print(&apos;Name is %s&apos; %(name,)) format简洁，%无法同时传递一个变量和元组 迭代器和生成器123456789101112131415161718192021222324252627mylist = [1, 2, 3]for i in mylist: print(i)# mylist is an iterable# These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.# yield is a keyword that is used like return, except the function will return a generator.def createGenerator(): mylist = range(3) for i in mylist: yield i*i# create a generatormygenerator = createGenerator()print(mygenerator)for i in mygenerator: print(i)print(&apos;****&apos;)# To master yield, you must understand that when you call the function, the code you have written in the function body does not run.for j in mygenerator: print(j)&quot;&quot;&quot;Generators are iterators, a kind of iterable you can only iterate over once. Generators do not store all the values in memory, they generate the values on the fly.&quot;&quot;&quot; *args and **kwargs”不确定你的函数里将要传递多少参数时你可以用*args。例如，它可以传递任意数量的参数12345def print_everything(*args): for count, thing in enumerate(args): print(&apos;&#123;0&#125;. &#123;1&#125;&apos;.format(count, thing))print_everything(&apos;apple&apos;, &apos;banana&apos;, &apos;cabbage&apos;) **kwargs允许你使用没有事先定义的参数名12345def table_things(**kwargs): for name, value in kwargs.items(): print(&apos;&#123;0&#125;=&#123;1&#125;&apos;.format(name, value))table_things(apple = &apos;fruit&apos;, cabbage = &apos;vegetable&apos;) 也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给*args和**kwargs。命名参数在列表的最前端，*args和**kwargs可以同时在函数的定义中，但是*args必须在**kwargs前面. 面向切面编程AOP和装饰器 装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。 装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 123456789def makebold(fn): def wrapped(): return &quot;&lt;b&gt;&quot; + fn() + &quot;&lt;/b&gt;&quot; return wrappeddef makeitalic(fn): def wrapped(): return &quot;&lt;i&gt;&quot; + fn() + &quot;&lt;/i&gt;&quot; return wrapped 装饰器的作用就是为已经存在的对象添加额外的功能 123456@makebold@makeitalicdef hello(): return &quot;hello world&quot;print(hello()) 鸭子类型当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。并不关心对象是什么类型，到底是不是鸭子，只关心行为。在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。 Python中函数重载 函数重载主要是为了解决两个问题:可变参数类型、可变参数个数。 一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载。情况1：函数功能相同，但是参数类型不同，根本不需要处理，因为python可以接受任何类型的参数情况2：函数功能相同，但参数个数不同，答案就是缺省参数。python 自然就不需要函数重载。 new和init的区别 __new__是一个静态方法,而__init__是一个实例方法. __new__方法会返回一个创建的实例,而__init__什么都不返回. 只有在__new__返回一个cls的实例时后面的__init__才能被调用. 当创建一个新实例时调用__new__,初始化一个实例时用__init__. ps: metaclass是创建类时起作用.所以我们可以分别使用metaclass,new和init来分别在类创建,实例创建和实例初始化的时候做一些小手脚. 单例模式使用new方法123456789class Singleton(object): def __new__(cls, *args, **kw): if not hasattr(cls, &apos;_instance&apos;): orig = super(Singleton, cls) cls._instance = orig.__new__(cls, *args, **kw) return cls._instance class MyClass(Singleton): a = 1 共享属性 创建实例时把所有实例的__dict__指向同一个字典,这样它们具有相同的属性和方法.123456789class Borg(object): _state = &#123;&#125; def __new__(cls, *args, **kw): ob = super(Borg, cls).__new__(cls, *args, **kw) ob.__dict__ = cls._state return ob class MyClass2(Borg): a = 1 装饰器版本1234567891011def singleton(cls, *args, **kw): instances = &#123;&#125; def getinstance(): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return getinstance @singletonclass MyClass: ... import方法123456# mysingleton.pyclass My_Singleton(object): def foo(self): pass my_singleton = My_Singleton() 123# to use# from mysingleton import my_singleton# my_singleton.foo() 作用域 一个变量的作用域总是由在代码中被赋值的地方所决定的。 当 Python 遇到一个变量的话他会按照这样的顺序进行搜索： 本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in） 闭包(closure)闭包(closure)是函数式编程的重要的语法结构创建一个闭包必须满足以下几点: 必须有一个内嵌函数 内嵌函数必须引用外部函数中的变量 外部函数的返回值必须是内嵌函数 lambda函数lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。1map( lambda x: x*x, [y for y in range(10)] ) Python里的拷贝 copy浅拷贝，没有拷贝子对象，所以原始数据改变，子对象会改变 深拷贝，包含对象里面的自对象的拷贝，所以原始对象的改变不会造成深拷贝里任何子元素的改变1234567891011121314151617181920import copya = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]] #原始对象 b = a #赋值，传对象的引用c = copy.copy(a) #对象拷贝，浅拷贝d = copy.deepcopy(a) #对象拷贝，深拷贝 a.append(5) #修改对象aa[4].append(&apos;c&apos;) #修改对象a中的[&apos;a&apos;, &apos;b&apos;]数组对象 print(&apos;a = &apos;, a)print(&apos;b = &apos;, b)print(&apos;c = &apos;, c)print(&apos;d = &apos;, d)# 输出结果：# a = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]# b = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]# c = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]# d = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]] Python垃圾回收机制Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。 引用计数PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。 标记-清除机制基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。 分代技术整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。 Python的isis是对比地址，==是对比值 read，readline和readlines read 读取整个文件 readline 读取下一行,使用生成器方法 readlines 读取整个文件到一个迭代器以供我们遍历]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
